// Autogenerated by opgen.py
import Foundation
public func RealityKitTexture2DGradient(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, dynamic_min_lod_clamp: SGScalar, gradient_dPdx: SGVector, gradient_dPdy: SGVector, offset: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "gradient_dPdx", connection: gradient_dPdx),
        .init(name: "gradient_dPdy", connection: gradient_dPdy),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DGradient")
}
public func RealityKitTexture2DLOD(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, lod: SGScalar, offset: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "lod", connection: lod),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DLOD")
}
public func RealityKitTexture2DPixelGradient(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, dynamic_min_lod_clamp: SGScalar, gradient_dPdx: SGVector, gradient_dPdy: SGVector, offset: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "filter", connection: filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "gradient_dPdx", connection: gradient_dPdx),
        .init(name: "gradient_dPdy", connection: gradient_dPdy),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DPixelGradient")
}
public func RealityKitTexture2DPixelLOD(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, lod: SGScalar, offset: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "filter", connection: filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "lod", connection: lod),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DPixelLOD")
}
public func RealityKitTexture2DPixel(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, bias: SGScalar, dynamic_min_lod_clamp: SGScalar, offset: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "filter", connection: filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DPixel")
}
public func RealityKitTexture2D(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, bias: SGScalar, dynamic_min_lod_clamp: SGScalar, offset: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2D")
}
public func RealityKitTextureCubeGradient(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, dynamic_min_lod_clamp: SGScalar, gradientcube_dPdx: SGVector, gradientcube_dPdy: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "gradientcube_dPdx", connection: gradientcube_dPdx),
        .init(name: "gradientcube_dPdy", connection: gradientcube_dPdy),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeGradient_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeGradient_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureCubeGradient")
}
public func RealityKitTextureCubeLOD(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, lod: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "lod", connection: lod),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeLOD_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeLOD_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureCubeLOD")
}
public func RealityKitTextureCube(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, bias: SGScalar, dynamic_min_lod_clamp: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCube_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCube_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureCube")
}
public func RealityKitTextureRead(file: TextureResource, default: SGValue, x: SGScalar, y: SGScalar, lod: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "x", connection: x),
        .init(name: "y", connection: y),
        .init(name: "lod", connection: lod),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureRead_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureRead_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureRead")
}
public func UsdPrimvarReader(varname: SGString, fallback: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "varname", connection: varname),
        .init(name: "fallback", connection: fallback),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if false {
        return SGString(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for UsdPrimvarReader")
}
public func UsdTransform2d(_ in: SGVector, rotation: SGScalar, scale: SGVector, translation: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "rotation", connection: rotation),
        .init(name: "scale", connection: scale),
        .init(name: "translation", connection: translation),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdTransform2d",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    return SGError("Unsupported input data types for UsdTransform2d")
}
public func absval(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for absval")
}
public func acos(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for acos")
}
public func add(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_add_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_add_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for add")
}
public func add_displacementshader(_ in1: String, _ in2: String) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_add_displacementshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for add_displacementshader")
}
public func add_surfaceshader(_ in1: String, _ in2: String) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_add_surfaceshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for add_surfaceshader")
}
public func add_volumeshader(_ in1: String, _ in2: String) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_add_volumeshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for add_volumeshader")
}
public func ambientocclusion(coneangle: SGScalar, maxdistance: SGScalar) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "coneangle", connection: coneangle),
        .init(name: "maxdistance", connection: maxdistance),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ambientocclusion_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for ambientocclusion")
}
public func asin(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for asin")
}
public func atan2(iny: SGValue, inx: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "iny", connection: iny),
        .init(name: "inx", connection: inx),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for atan2")
}
public func bitangent(space: SGString, index: SGScalar) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
        .init(name: "index", connection: index),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_bitangent_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for bitangent")
}
public func blur(_ in: SGValue, size: SGScalar, filtertype: SGString) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "size", connection: size),
        .init(name: "filtertype", connection: filtertype),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for blur")
}
public func burn(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for burn")
}
public func ceil(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ceil")
}
public func cellnoise2d(texcoord: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_cellnoise2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for cellnoise2d")
}
public func cellnoise3d(position: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_cellnoise3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for cellnoise3d")
}
public func clamp(_ in: SGValue, low: SGValue, high: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "low", connection: low),
        .init(name: "high", connection: high),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for clamp")
}
public func contrast(_ in: SGValue, amount: SGValue, pivot: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
        .init(name: "pivot", connection: pivot),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for contrast")
}
public func cos(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for cos")
}
public func crossproduct(_ in1: SGVector, _ in2: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for crossproduct")
}
public func determinant(_ in: SGValue) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for determinant")
}
public func difference(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for difference")
}
public func disjointover(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_disjointover_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for disjointover")
}
public func divide(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for divide")
}
public func dodge(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for dodge")
}
public func dot(_ in: SGValue, note: SGString) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "note", connection: note),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return TextureResource(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_filename",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.asset)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGString(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for dot")
}
public func dot_displacementshader(_ in: String, note: SGString) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "note", connection: note),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_displacementshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for dot_displacementshader")
}
public func dot_lightshader(_ in: String, note: SGString) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "note", connection: note),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_lightshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for dot_lightshader")
}
public func dot_surfaceshader(_ in: String, note: SGString) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "note", connection: note),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_surfaceshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for dot_surfaceshader")
}
public func dot_volumeshader(_ in: String, note: SGString) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "note", connection: note),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_volumeshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for dot_volumeshader")
}
public func dotproduct(_ in1: SGVector, _ in2: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for dotproduct")
}
public func exp(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for exp")
}
public func extract(_ in: SGValue, index: SGScalar) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "index", connection: index),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for extract")
}
public func floor(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for floor")
}
public func fractal3d(amplitude: SGValue, octaves: SGScalar, lacunarity: SGScalar, diminish: SGScalar, position: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "octaves", connection: octaves),
        .init(name: "lacunarity", connection: lacunarity),
        .init(name: "diminish", connection: diminish),
        .init(name: "position", connection: position),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for fractal3d")
}
public func geomcolor(index: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "index", connection: index),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_geomcolor_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_geomcolor_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geomcolor_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for geomcolor")
}
public func geompropvalue(geomprop: SGString, default: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "geomprop", connection: geomprop),
        .init(name: "default", connection: default),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if false {
        return SGString(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for geompropvalue")
}
public func heighttonormal(_ in: SGScalar, scale: SGScalar) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "scale", connection: scale),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_heighttonormal_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for heighttonormal")
}
public func hsvadjust(_ in: SGColor, amount: SGVector) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for hsvadjust")
}
public func hsvtorgb(_ in: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for hsvtorgb")
}
public func ifequal(value1: SGValue, value2: SGValue, in1: SGValue, in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatB",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfB",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ifequal")
}
public func ifgreater(value1: SGScalar, value2: SGScalar, in1: SGValue, in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ifgreater")
}
public func ifgreatereq(value1: SGScalar, value2: SGScalar, in1: SGValue, in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ifgreatereq")
}
public func image(file: TextureResource, layer: SGString, default: SGValue, texcoord: SGVector, uaddressmode: SGString, vaddressmode: SGString, filtertype: SGString, framerange: SGString, frameoffset: SGScalar, frameendaction: SGString) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "layer", connection: layer),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "uaddressmode", connection: uaddressmode),
        .init(name: "vaddressmode", connection: vaddressmode),
        .init(name: "filtertype", connection: filtertype),
        .init(name: "framerange", connection: framerange),
        .init(name: "frameoffset", connection: frameoffset),
        .init(name: "frameendaction", connection: frameendaction),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_image_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_image_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for image")
}
public func in(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_in_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for in")
}
public func inside(_ in: SGValue, mask: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mask", connection: mask),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for inside")
}
public func invertmatrix(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    return SGError("Unsupported input data types for invertmatrix")
}
public func ln(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ln")
}
public func luminance(_ in: SGColor, lumacoeffs: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "lumacoeffs", connection: lumacoeffs),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for luminance")
}
public func magnitude(_ in: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for magnitude")
}
public func mask(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_mask_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for mask")
}
public func matte(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_matte_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for matte")
}
public func max(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_max_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for max")
}
public func min(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_min_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for min")
}
public func minus(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for minus")
}
public func mix(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for mix")
}
public func mix_displacementshader(fg: String, bg: String, mix: SGScalar) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_displacementshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for mix_displacementshader")
}
public func mix_surfaceshader(fg: String, bg: String, mix: SGScalar) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_surfaceshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for mix_surfaceshader")
}
public func mix_volumeshader(fg: String, bg: String, mix: SGScalar) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_volumeshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for mix_volumeshader")
}
public func modulo(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for modulo")
}
public func multiply(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for multiply")
}
public func multiply_displacementshaderF(_ in1: String, _ in2: SGScalar) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_displacementshaderF",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for multiply_displacementshaderF")
}
public func multiply_displacementshaderV(_ in1: String, _ in2: SGVector) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_displacementshaderV",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for multiply_displacementshaderV")
}
public func multiply_surfaceshaderC(_ in1: String, _ in2: SGColor) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_surfaceshaderC",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for multiply_surfaceshaderC")
}
public func multiply_surfaceshaderF(_ in1: String, _ in2: SGScalar) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_surfaceshaderF",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for multiply_surfaceshaderF")
}
public func multiply_volumeshaderC(_ in1: String, _ in2: SGColor) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_volumeshaderC",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for multiply_volumeshaderC")
}
public func multiply_volumeshaderF(_ in1: String, _ in2: SGScalar) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_volumeshaderF",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for multiply_volumeshaderF")
}
public func noise2d(amplitude: SGValue, pivot: SGScalar, texcoord: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "pivot", connection: pivot),
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for noise2d")
}
public func noise3d(amplitude: SGValue, pivot: SGScalar, position: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "pivot", connection: pivot),
        .init(name: "position", connection: position),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for noise3d")
}
public func normal_map_decode(_ in: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normal_map_decode",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for normal_map_decode")
}
public func normal(space: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normal_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for normal")
}
public func normalize(_ in: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for normalize")
}
public func normalmap(_ in: SGVector, space: SGString, scale: SGValue, normal: SGVector, tangent: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "space", connection: space),
        .init(name: "scale", connection: scale),
        .init(name: "normal", connection: normal),
        .init(name: "tangent", connection: tangent),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for normalmap")
}
public func out(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_out_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for out")
}
public func outside(_ in: SGValue, mask: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mask", connection: mask),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for outside")
}
public func over(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_over_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for over")
}
public func overlay(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for overlay")
}
public func place2d(texcoord: SGVector, pivot: SGVector, scale: SGVector, rotate: SGScalar, offset: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "pivot", connection: pivot),
        .init(name: "scale", connection: scale),
        .init(name: "rotate", connection: rotate),
        .init(name: "offset", connection: offset),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_place2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    return SGError("Unsupported input data types for place2d")
}
public func plus(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for plus")
}
public func position(space: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_position_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for position")
}
public func power(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_power_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_power_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for power")
}
public func premult(_ in: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_premult_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for premult")
}
public func ramp4(valuetl: SGValue, valuetr: SGValue, valuebl: SGValue, valuebr: SGValue, texcoord: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "valuetl", connection: valuetl),
        .init(name: "valuetr", connection: valuetr),
        .init(name: "valuebl", connection: valuebl),
        .init(name: "valuebr", connection: valuebr),
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ramp4")
}
public func ramplr(valuel: SGValue, valuer: SGValue, texcoord: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "valuel", connection: valuel),
        .init(name: "valuer", connection: valuer),
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ramplr")
}
public func ramptb(valuet: SGValue, valueb: SGValue, texcoord: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "valuet", connection: valuet),
        .init(name: "valueb", connection: valueb),
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ramptb")
}
public func range(_ in: SGValue, inlow: SGValue, inhigh: SGValue, gamma: SGValue, outlow: SGValue, outhigh: SGValue, doclamp: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "inlow", connection: inlow),
        .init(name: "inhigh", connection: inhigh),
        .init(name: "gamma", connection: gamma),
        .init(name: "outlow", connection: outlow),
        .init(name: "outhigh", connection: outhigh),
        .init(name: "doclamp", connection: doclamp),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_range_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for range")
}
public func cameraposition(space: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cameraposition_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for cameraposition")
}
public func cubeimage(file: TextureResource, default: SGValue, texcoord: SGVector, filtertype: SGString) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "filtertype", connection: filtertype),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for cubeimage")
}
public func fractional(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for fractional")
}
public func geometry_switch_cameraindex(mono: SGValue, left: SGValue, right: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "mono", connection: mono),
        .init(name: "left", connection: left),
        .init(name: "right", connection: right),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for geometry_switch_cameraindex")
}
public func geometrymodifier_vertexshader(modelPositionOffset: SGVector, color: SGColor, normal: SGVector, bitangent: SGVector, uv0: SGVector, uv1: SGVector, userAttribute: SGVector, userAttributeHalf4_0: SGVector, userAttributeHalf4_1: SGVector, userAttributeHalf4_2: SGVector, userAttributeHalf4_3: SGVector, userAttributeHalf2_0: SGVector, userAttributeHalf2_1: SGVector) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "modelPositionOffset", connection: modelPositionOffset),
        .init(name: "color", connection: color),
        .init(name: "normal", connection: normal),
        .init(name: "bitangent", connection: bitangent),
        .init(name: "uv0", connection: uv0),
        .init(name: "uv1", connection: uv1),
        .init(name: "userAttribute", connection: userAttribute),
        .init(name: "userAttributeHalf4_0", connection: userAttributeHalf4_0),
        .init(name: "userAttributeHalf4_1", connection: userAttributeHalf4_1),
        .init(name: "userAttributeHalf4_2", connection: userAttributeHalf4_2),
        .init(name: "userAttributeHalf4_3", connection: userAttributeHalf4_3),
        .init(name: "userAttributeHalf2_0", connection: userAttributeHalf2_0),
        .init(name: "userAttributeHalf2_1", connection: userAttributeHalf2_1),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometrymodifier_vertexshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for geometrymodifier_vertexshader")
}
public func image_bias(file: TextureResource, default: SGValue, texcoord: SGVector, bias: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_bias")
}
public func image_bias_min_lod_clamp(file: TextureResource, default: SGValue, texcoord: SGVector, bias: SGScalar, min_lod_clamp: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_bias_min_lod_clamp")
}
public func image(file: TextureResource, default: SGValue, texcoord: SGVector, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image")
}
public func image_gradient2d(file: TextureResource, default: SGValue, texcoord: SGVector, gradient2d_x: SGString, gradient2d_y: SGString, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "gradient2d_x", connection: gradient2d_x),
        .init(name: "gradient2d_y", connection: gradient2d_y),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_gradient2d")
}
public func image_gradient2d_min_lod_clamp(file: TextureResource, default: SGValue, texcoord: SGVector, gradient2d_x: SGString, gradient2d_y: SGString, min_lod_clamp: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "gradient2d_x", connection: gradient2d_x),
        .init(name: "gradient2d_y", connection: gradient2d_y),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_gradient2d_min_lod_clamp")
}
public func image_lod(file: TextureResource, default: SGValue, texcoord: SGVector, level: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "level", connection: level),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_lod")
}
public func image_min_lod_clamp(file: TextureResource, default: SGValue, texcoord: SGVector, min_lod_clamp: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_min_lod_clamp")
}
public func logical_and(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_logical_and",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    return SGError("Unsupported input data types for logical_and")
}
public func logical_not(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_logical_not",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    return SGError("Unsupported input data types for logical_not")
}
public func logical_or(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_logical_or",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    return SGError("Unsupported input data types for logical_or")
}
public func logical_xor(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_logical_xor",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    return SGError("Unsupported input data types for logical_xor")
}
public func oneminus(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for oneminus")
}
public func pbr_surfaceshader(baseColor: SGColor, emissiveColor: SGColor, normal: SGVector, roughness: SGScalar, metallic: SGScalar, ambientOcclusion: SGScalar, specular: SGScalar, opacity: SGScalar, opacityThreshold: SGScalar, clearcoat: SGScalar, clearcoatRoughness: SGScalar, hasPremultipliedAlpha: SGValue) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "baseColor", connection: baseColor),
        .init(name: "emissiveColor", connection: emissiveColor),
        .init(name: "normal", connection: normal),
        .init(name: "roughness", connection: roughness),
        .init(name: "metallic", connection: metallic),
        .init(name: "ambientOcclusion", connection: ambientOcclusion),
        .init(name: "specular", connection: specular),
        .init(name: "opacity", connection: opacity),
        .init(name: "opacityThreshold", connection: opacityThreshold),
        .init(name: "clearcoat", connection: clearcoat),
        .init(name: "clearcoatRoughness", connection: clearcoatRoughness),
        .init(name: "hasPremultipliedAlpha", connection: hasPremultipliedAlpha),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_pbr_surfaceshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for pbr_surfaceshader")
}
public func reflect(_ in: SGVector, normal: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "normal", connection: normal),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_reflect_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for reflect")
}
public func refract(_ in: SGVector, normal: SGVector, eta: SGScalar) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "normal", connection: normal),
        .init(name: "eta", connection: eta),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_refract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for refract")
}
public func step(_ in: SGValue, edge: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "edge", connection: edge),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for step")
}
public func unlit_surfaceshader(color: SGColor, opacity: SGScalar, opacityThreshold: SGScalar, applyPostProcessToneMap: SGValue, hasPremultipliedAlpha: SGValue) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "color", connection: color),
        .init(name: "opacity", connection: opacity),
        .init(name: "opacityThreshold", connection: opacityThreshold),
        .init(name: "applyPostProcessToneMap", connection: applyPostProcessToneMap),
        .init(name: "hasPremultipliedAlpha", connection: hasPremultipliedAlpha),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_unlit_surfaceshader",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for unlit_surfaceshader")
}
public func viewdirection(space: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_viewdirection_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for viewdirection")
}
public func remap(_ in: SGValue, inlow: SGValue, inhigh: SGValue, outlow: SGValue, outhigh: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "inlow", connection: inlow),
        .init(name: "inhigh", connection: inhigh),
        .init(name: "outlow", connection: outlow),
        .init(name: "outhigh", connection: outhigh),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for remap")
}
public func rgbtohsv(_ in: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for rgbtohsv")
}
public func rotate2d(_ in: SGVector, amount: SGScalar) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_rotate2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    return SGError("Unsupported input data types for rotate2d")
}
public func rotate3d(_ in: SGVector, amount: SGScalar, axis: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
        .init(name: "axis", connection: axis),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_rotate3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for rotate3d")
}
public func round(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_round_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_round_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for round")
}
public func safepower(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for safepower")
}
public func saturate(_ in: SGColor, amount: SGScalar, lumacoeffs: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
        .init(name: "lumacoeffs", connection: lumacoeffs),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for saturate")
}
public func screen(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for screen")
}
public func sign(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for sign")
}
public func sin(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for sin")
}
public func smoothstep(_ in: SGValue, low: SGValue, high: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "low", connection: low),
        .init(name: "high", connection: high),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for smoothstep")
}
public func splitlr(valuel: SGValue, valuer: SGValue, center: SGScalar, texcoord: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "valuel", connection: valuel),
        .init(name: "valuer", connection: valuer),
        .init(name: "center", connection: center),
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for splitlr")
}
public func splittb(valuet: SGValue, valueb: SGValue, center: SGScalar, texcoord: SGVector) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "valuet", connection: valuet),
        .init(name: "valueb", connection: valueb),
        .init(name: "center", connection: center),
        .init(name: "texcoord", connection: texcoord),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for splittb")
}
public func sqrt(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for sqrt")
}
public func subtract(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for subtract")
}
public func surfacematerial(surfaceshader: String, displacementshader: String) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "surfaceshader", connection: surfaceshader),
        .init(name: "displacementshader", connection: displacementshader),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_surfacematerial",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for surfacematerial")
}
public func switch(_ in1: SGValue, _ in2: SGValue, _ in3: SGValue, _ in4: SGValue, _ in5: SGValue, _ in6: SGValue, _ in7: SGValue, _ in8: SGValue, _ in9: SGValue, _ in10: SGValue, which: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
        .init(name: "in3", connection: in3),
        .init(name: "in4", connection: in4),
        .init(name: "in5", connection: in5),
        .init(name: "in6", connection: in6),
        .init(name: "in7", connection: in7),
        .init(name: "in8", connection: in8),
        .init(name: "in9", connection: in9),
        .init(name: "in10", connection: in10),
        .init(name: "which", connection: which),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for switch")
}
public func tan(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for tan")
}
public func tangent(space: SGString, index: SGScalar) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
        .init(name: "index", connection: index),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tangent_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for tangent")
}
public func texcoord(index: SGScalar) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "index", connection: index),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_texcoord_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_texcoord_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for texcoord")
}
public func tiledimage(file: TextureResource, default: SGValue, texcoord: SGVector, uvtiling: SGVector, uvoffset: SGVector, realworldimagesize: SGVector, realworldtilesize: SGVector, filtertype: SGString, framerange: SGString, frameoffset: SGScalar, frameendaction: SGString) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "uvtiling", connection: uvtiling),
        .init(name: "uvoffset", connection: uvoffset),
        .init(name: "realworldimagesize", connection: realworldimagesize),
        .init(name: "realworldtilesize", connection: realworldtilesize),
        .init(name: "filtertype", connection: filtertype),
        .init(name: "framerange", connection: framerange),
        .init(name: "frameoffset", connection: frameoffset),
        .init(name: "frameendaction", connection: frameendaction),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for tiledimage")
}
public func time(fps: SGScalar) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "fps", connection: fps),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_time_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for time")
}
public func transformmatrix(_ in: SGVector, mat: SGValue) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mat", connection: mat),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for transformmatrix")
}
public func transformmatrix_vector2M3(_ in: SGVector, mat: SGValue) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mat", connection: mat),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector2M3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    return SGError("Unsupported input data types for transformmatrix_vector2M3")
}
public func transformmatrix_vector3M4(_ in: SGVector, mat: SGValue) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mat", connection: mat),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector3M4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for transformmatrix_vector3M4")
}
public func transformnormal(_ in: SGVector, fromspace: SGString, tospace: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "fromspace", connection: fromspace),
        .init(name: "tospace", connection: tospace),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformnormal_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for transformnormal")
}
public func transformpoint(_ in: SGVector, fromspace: SGString, tospace: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "fromspace", connection: fromspace),
        .init(name: "tospace", connection: tospace),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformpoint_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for transformpoint")
}
public func transformvector(_ in: SGVector, fromspace: SGString, tospace: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "fromspace", connection: fromspace),
        .init(name: "tospace", connection: tospace),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformvector_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for transformvector")
}
public func transpose(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if false {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    return SGError("Unsupported input data types for transpose")
}
public func triplanarprojection(filex: TextureResource, filey: TextureResource, filez: TextureResource, layerx: SGString, layery: SGString, layerz: SGString, default: SGValue, position: SGVector, normal: SGVector, filtertype: SGString, framerange: SGString, frameoffset: SGScalar, frameendaction: SGString) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "filex", connection: filex),
        .init(name: "filey", connection: filey),
        .init(name: "filez", connection: filez),
        .init(name: "layerx", connection: layerx),
        .init(name: "layery", connection: layery),
        .init(name: "layerz", connection: layerz),
        .init(name: "default", connection: default),
        .init(name: "position", connection: position),
        .init(name: "normal", connection: normal),
        .init(name: "filtertype", connection: filtertype),
        .init(name: "framerange", connection: framerange),
        .init(name: "frameoffset", connection: frameoffset),
        .init(name: "frameendaction", connection: frameendaction),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for triplanarprojection")
}
public func unpremult(_ in: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if false {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_unpremult_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for unpremult")
}
public func updirection(space: SGString) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_updirection_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for updirection")
}
public func volumematerial(volumeshader: String) -> String {
    let inputs: [SGNode.Input] = [
        .init(name: "volumeshader", connection: volumeshader),
    ]
    if false {
        return String(source: .nodeOutput(SGNode(
            nodeType: "ND_volumematerial",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    return SGError("Unsupported input data types for volumematerial")
}
public func worleynoise2d(texcoord: SGVector, jitter: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "jitter", connection: jitter),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_worleynoise2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_worleynoise2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_worleynoise2d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for worleynoise2d")
}
public func worleynoise3d(position: SGVector, jitter: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
        .init(name: "jitter", connection: jitter),
    ]
    if false {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_worleynoise3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_worleynoise3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if false {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_worleynoise3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for worleynoise3d")
}
