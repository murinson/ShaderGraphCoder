// Autogenerated by opgen.py
import Foundation
public func RealityKitTexture2DGradient(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, dynamic_min_lod_clamp: SGScalar, gradient_dPdx: SGVector, gradient_dPdy: SGVector, offset: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard dynamic_min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected dynamic_min_lod_clamp data type to be SGDataType.float, but got \(dynamic_min_lod_clamp.dataType).")
    }
    guard gradient_dPdx.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected gradient_dPdx data type to be SGDataType.vector2f, but got \(gradient_dPdx.dataType).")
    }
    guard gradient_dPdy.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected gradient_dPdy data type to be SGDataType.vector2f, but got \(gradient_dPdy.dataType).")
    }
    guard offset.dataType == SGDataType.vector2i else {
        return SGError("Invalid RealityKitTexture2DGradient input. Expected offset data type to be SGDataType.vector2i, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "gradient_dPdx", connection: gradient_dPdx),
        .init(name: "gradient_dPdy", connection: gradient_dPdy),
        .init(name: "offset", connection: offset),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DGradient")
}
public func RealityKitTexture2DLOD(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, lod: SGScalar, offset: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard lod.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected lod data type to be SGDataType.float, but got \(lod.dataType).")
    }
    guard offset.dataType == SGDataType.vector2i else {
        return SGError("Invalid RealityKitTexture2DLOD input. Expected offset data type to be SGDataType.vector2i, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "lod", connection: lod),
        .init(name: "offset", connection: offset),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DLOD")
}
public func RealityKitTexture2DPixelGradient(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, dynamic_min_lod_clamp: SGScalar, gradient_dPdx: SGVector, gradient_dPdy: SGVector, offset: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected filter data type to be SGDataType.string, but got \(filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard dynamic_min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected dynamic_min_lod_clamp data type to be SGDataType.float, but got \(dynamic_min_lod_clamp.dataType).")
    }
    guard gradient_dPdx.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected gradient_dPdx data type to be SGDataType.vector2f, but got \(gradient_dPdx.dataType).")
    }
    guard gradient_dPdy.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected gradient_dPdy data type to be SGDataType.vector2f, but got \(gradient_dPdy.dataType).")
    }
    guard offset.dataType == SGDataType.vector2i else {
        return SGError("Invalid RealityKitTexture2DPixelGradient input. Expected offset data type to be SGDataType.vector2i, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "filter", connection: filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "gradient_dPdx", connection: gradient_dPdx),
        .init(name: "gradient_dPdy", connection: gradient_dPdy),
        .init(name: "offset", connection: offset),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DPixelGradient")
}
public func RealityKitTexture2DPixelLOD(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, lod: SGScalar, offset: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected filter data type to be SGDataType.string, but got \(filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard lod.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected lod data type to be SGDataType.float, but got \(lod.dataType).")
    }
    guard offset.dataType == SGDataType.vector2i else {
        return SGError("Invalid RealityKitTexture2DPixelLOD input. Expected offset data type to be SGDataType.vector2i, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "filter", connection: filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "lod", connection: lod),
        .init(name: "offset", connection: offset),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DPixelLOD")
}
public func RealityKitTexture2DPixel(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, bias: SGScalar, dynamic_min_lod_clamp: SGScalar, offset: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected filter data type to be SGDataType.string, but got \(filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard bias.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected bias data type to be SGDataType.float, but got \(bias.dataType).")
    }
    guard dynamic_min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected dynamic_min_lod_clamp data type to be SGDataType.float, but got \(dynamic_min_lod_clamp.dataType).")
    }
    guard offset.dataType == SGDataType.vector2i else {
        return SGError("Invalid RealityKitTexture2DPixel input. Expected offset data type to be SGDataType.vector2i, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "filter", connection: filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "offset", connection: offset),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2DPixel")
}
public func RealityKitTexture2D(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, bias: SGScalar, dynamic_min_lod_clamp: SGScalar, offset: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTexture2D input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2D input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2D input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2D input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2D input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2D input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTexture2D input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTexture2D input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2D input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2D input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid RealityKitTexture2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard bias.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2D input. Expected bias data type to be SGDataType.float, but got \(bias.dataType).")
    }
    guard dynamic_min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTexture2D input. Expected dynamic_min_lod_clamp data type to be SGDataType.float, but got \(dynamic_min_lod_clamp.dataType).")
    }
    guard offset.dataType == SGDataType.vector2i else {
        return SGError("Invalid RealityKitTexture2D input. Expected offset data type to be SGDataType.vector2i, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "offset", connection: offset),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTexture2D")
}
public func RealityKitTextureCubeGradient(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, dynamic_min_lod_clamp: SGScalar, gradientcube_dPdx: SGVector, gradientcube_dPdy: SGVector) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector3f else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord.dataType).")
    }
    guard dynamic_min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected dynamic_min_lod_clamp data type to be SGDataType.float, but got \(dynamic_min_lod_clamp.dataType).")
    }
    guard gradientcube_dPdx.dataType == SGDataType.vector3f else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected gradientcube_dPdx data type to be SGDataType.vector3f, but got \(gradientcube_dPdx.dataType).")
    }
    guard gradientcube_dPdy.dataType == SGDataType.vector3f else {
        return SGError("Invalid RealityKitTextureCubeGradient input. Expected gradientcube_dPdy data type to be SGDataType.vector3f, but got \(gradientcube_dPdy.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
        .init(name: "gradientcube_dPdx", connection: gradientcube_dPdx),
        .init(name: "gradientcube_dPdy", connection: gradientcube_dPdy),
    ]
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeGradient_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeGradient_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureCubeGradient")
}
public func RealityKitTextureCubeLOD(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, lod: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector3f else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord.dataType).")
    }
    guard lod.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCubeLOD input. Expected lod data type to be SGDataType.float, but got \(lod.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "lod", connection: lod),
    ]
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeLOD_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeLOD_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureCubeLOD")
}
public func RealityKitTextureCube(file: TextureResource, u_wrap_mode: SGString, v_wrap_mode: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, max_lod_clamp: SGScalar, min_lod_clamp: SGScalar, default: SGValue, texcoord: SGVector, bias: SGScalar, dynamic_min_lod_clamp: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTextureCube input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard u_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCube input. Expected u_wrap_mode data type to be SGDataType.string, but got \(u_wrap_mode.dataType).")
    }
    guard v_wrap_mode.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCube input. Expected v_wrap_mode data type to be SGDataType.string, but got \(v_wrap_mode.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCube input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCube input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCube input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid RealityKitTextureCube input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTextureCube input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard max_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCube input. Expected max_lod_clamp data type to be SGDataType.float, but got \(max_lod_clamp.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCube input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector3f else {
        return SGError("Invalid RealityKitTextureCube input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord.dataType).")
    }
    guard bias.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCube input. Expected bias data type to be SGDataType.float, but got \(bias.dataType).")
    }
    guard dynamic_min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid RealityKitTextureCube input. Expected dynamic_min_lod_clamp data type to be SGDataType.float, but got \(dynamic_min_lod_clamp.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "u_wrap_mode", connection: u_wrap_mode),
        .init(name: "v_wrap_mode", connection: v_wrap_mode),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "max_lod_clamp", connection: max_lod_clamp),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "dynamic_min_lod_clamp", connection: dynamic_min_lod_clamp),
    ]
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCube_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCube_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureCube")
}
public func RealityKitTextureRead(file: TextureResource, default: SGValue, x: SGScalar, y: SGScalar, lod: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid RealityKitTextureRead input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard x.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTextureRead input. Expected x data type to be SGDataType.int, but got \(x.dataType).")
    }
    guard y.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTextureRead input. Expected y data type to be SGDataType.int, but got \(y.dataType).")
    }
    guard lod.dataType == SGDataType.int else {
        return SGError("Invalid RealityKitTextureRead input. Expected lod data type to be SGDataType.int, but got \(lod.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "x", connection: x),
        .init(name: "y", connection: y),
        .init(name: "lod", connection: lod),
    ]
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureRead_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureRead_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for RealityKitTextureRead")
}
public func UsdPrimvarReader(varname: SGString, fallback: SGValue) -> SGValue {
    guard varname.dataType == SGDataType.string else {
        return SGError("Invalid UsdPrimvarReader input. Expected varname data type to be SGDataType.string, but got \(varname.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "varname", connection: varname),
        .init(name: "fallback", connection: fallback),
    ]
    if fallback.dataType == SGDataType.bool {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if fallback.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fallback.dataType == SGDataType.int {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if fallback.dataType == SGDataType.string {
        return SGString(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if fallback.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if fallback.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if fallback.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_UsdPrimvarReader_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for UsdPrimvarReader")
}
public func UsdTransform2d(_ in: SGVector, rotation: SGScalar, scale: SGVector, translation: SGVector) -> SGVector {
    guard in.dataType == SGDataType.vector2f else {
        return SGError("Invalid UsdTransform2d input. Expected in data type to be SGDataType.vector2f, but got \(in.dataType).")
    }
    guard rotation.dataType == SGDataType.float else {
        return SGError("Invalid UsdTransform2d input. Expected rotation data type to be SGDataType.float, but got \(rotation.dataType).")
    }
    guard scale.dataType == SGDataType.vector2f else {
        return SGError("Invalid UsdTransform2d input. Expected scale data type to be SGDataType.vector2f, but got \(scale.dataType).")
    }
    guard translation.dataType == SGDataType.vector2f else {
        return SGError("Invalid UsdTransform2d input. Expected translation data type to be SGDataType.vector2f, but got \(translation.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "rotation", connection: rotation),
        .init(name: "scale", connection: scale),
        .init(name: "translation", connection: translation),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_UsdTransform2d",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
public func absval(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for absval")
}
public func acos(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for acos")
}
public func add(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_add_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_add_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix22f && in2.dataType == SGDataType.matrix22f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in1.dataType == SGDataType.matrix22f && in2.dataType == SGDataType.float {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in1.dataType == SGDataType.matrix33f && in2.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in1.dataType == SGDataType.matrix33f && in2.dataType == SGDataType.float {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in1.dataType == SGDataType.matrix44f && in2.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in1.dataType == SGDataType.matrix44f && in2.dataType == SGDataType.float {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for add")
}
public func ambientocclusion(coneangle: SGScalar, maxdistance: SGScalar) -> SGScalar {
    guard coneangle.dataType == SGDataType.float else {
        return SGError("Invalid ambientocclusion input. Expected coneangle data type to be SGDataType.float, but got \(coneangle.dataType).")
    }
    guard maxdistance.dataType == SGDataType.float else {
        return SGError("Invalid ambientocclusion input. Expected maxdistance data type to be SGDataType.float, but got \(maxdistance.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "coneangle", connection: coneangle),
        .init(name: "maxdistance", connection: maxdistance),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_ambientocclusion_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
public func asin(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for asin")
}
public func atan2(iny: SGValue, inx: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "iny", connection: iny),
        .init(name: "inx", connection: inx),
    ]
    if iny.dataType == SGDataType.float && inx.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if iny.dataType == SGDataType.half && inx.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if iny.dataType == SGDataType.vector2h && inx.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if iny.dataType == SGDataType.vector3h && inx.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if iny.dataType == SGDataType.vector4h && inx.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if iny.dataType == SGDataType.vector2f && inx.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if iny.dataType == SGDataType.vector3f && inx.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if iny.dataType == SGDataType.vector4f && inx.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for atan2")
}
public func bitangent(space: SGString, index: SGScalar) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid bitangent input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    guard index.dataType == SGDataType.int else {
        return SGError("Invalid bitangent input. Expected index data type to be SGDataType.int, but got \(index.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
        .init(name: "index", connection: index),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_bitangent_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func blur(_ in: SGValue, size: SGScalar, filtertype: SGString) -> SGValue {
    guard filtertype.dataType == SGDataType.string else {
        return SGError("Invalid blur input. Expected filtertype data type to be SGDataType.string, but got \(filtertype.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "size", connection: size),
        .init(name: "filtertype", connection: filtertype),
    ]
    if in.dataType == SGDataType.color3f && size.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && size.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && size.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half && size.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2f && size.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && size.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && size.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for blur")
}
public func burn(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for burn")
}
public func ceil(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ceil")
}
public func cellnoise2d(texcoord: SGVector) -> SGScalar {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid cellnoise2d input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_cellnoise2d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
public func cellnoise3d(position: SGVector) -> SGScalar {
    guard position.dataType == SGDataType.vector3f else {
        return SGError("Invalid cellnoise3d input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_cellnoise3d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
public func clamp(_ in: SGValue, low: SGValue, high: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "low", connection: low),
        .init(name: "high", connection: high),
    ]
    if in.dataType == SGDataType.color3f && low.dataType == SGDataType.color3f && high.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color3f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && low.dataType == SGDataType.color4f && high.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.color4f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half && low.dataType == SGDataType.half && high.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h && low.dataType == SGDataType.vector2h && high.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector2h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h && low.dataType == SGDataType.vector3h && high.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector3h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h && low.dataType == SGDataType.vector4h && high.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector4h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f && low.dataType == SGDataType.vector2f && high.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector2f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && low.dataType == SGDataType.vector3f && high.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector3f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && low.dataType == SGDataType.vector4f && high.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in.dataType == SGDataType.vector4f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for clamp")
}
public func contrast(_ in: SGValue, amount: SGValue, pivot: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
        .init(name: "pivot", connection: pivot),
    ]
    if in.dataType == SGDataType.color3f && amount.dataType == SGDataType.color3f && pivot.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color3f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && amount.dataType == SGDataType.color4f && pivot.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.color4f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f && amount.dataType == SGDataType.vector2f && pivot.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector2f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && amount.dataType == SGDataType.vector3f && pivot.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector3f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && amount.dataType == SGDataType.vector4f && pivot.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in.dataType == SGDataType.vector4f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for contrast")
}
public func cos(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for cos")
}
public func crossproduct(_ in1: SGVector, _ in2: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for crossproduct")
}
public func determinant(_ in: SGValue) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.matrix22f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.matrix33f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.matrix44f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for determinant")
}
public func difference(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for difference")
}
public func disjointover(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGError("Invalid disjointover input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType).")
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGError("Invalid disjointover input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType).")
    }
    guard mix.dataType == SGDataType.float else {
        return SGError("Invalid disjointover input. Expected mix data type to be SGDataType.float, but got \(mix.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_disjointover_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func divide(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix22f && in2.dataType == SGDataType.matrix22f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in1.dataType == SGDataType.matrix33f && in2.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in1.dataType == SGDataType.matrix44f && in2.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for divide")
}
public func dodge(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for dodge")
}
public func dot(_ in: SGValue, note: SGString) -> SGValue {
    guard note.dataType == SGDataType.string else {
        return SGError("Invalid dot input. Expected note data type to be SGDataType.string, but got \(note.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "note", connection: note),
    ]
    if in.dataType == SGDataType.bool {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.asset {
        return TextureResource(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_filename",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.asset)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.int {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if in.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in.dataType == SGDataType.string {
        return SGString(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_dot_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for dot")
}
public func dotproduct(_ in1: SGVector, _ in2: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for dotproduct")
}
public func exp(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for exp")
}
public func extract(_ in: SGValue, index: SGScalar) -> SGScalar {
    guard index.dataType == SGDataType.int else {
        return SGError("Invalid extract input. Expected index data type to be SGDataType.int, but got \(index.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "index", connection: index),
    ]
    if in.dataType == SGDataType.color3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for extract")
}
public func floor(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for floor")
}
public func fractal3d(amplitude: SGValue, octaves: SGScalar, lacunarity: SGScalar, diminish: SGScalar, position: SGVector) -> SGValue {
    guard octaves.dataType == SGDataType.int else {
        return SGError("Invalid fractal3d input. Expected octaves data type to be SGDataType.int, but got \(octaves.dataType).")
    }
    guard lacunarity.dataType == SGDataType.float else {
        return SGError("Invalid fractal3d input. Expected lacunarity data type to be SGDataType.float, but got \(lacunarity.dataType).")
    }
    guard diminish.dataType == SGDataType.float else {
        return SGError("Invalid fractal3d input. Expected diminish data type to be SGDataType.float, but got \(diminish.dataType).")
    }
    guard position.dataType == SGDataType.vector3f else {
        return SGError("Invalid fractal3d input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "octaves", connection: octaves),
        .init(name: "lacunarity", connection: lacunarity),
        .init(name: "diminish", connection: diminish),
        .init(name: "position", connection: position),
    ]
    if amplitude.dataType == SGDataType.vector3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if amplitude.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for fractal3d")
}
public func geomcolor(index: SGScalar) -> SGValue {
    guard index.dataType == SGDataType.int else {
        return SGError("Invalid geomcolor input. Expected index data type to be SGDataType.int, but got \(index.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "index", connection: index),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_geomcolor_color3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color3f)])))
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_geomcolor_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_geomcolor_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
public func geompropvalue(geomprop: SGString, default: SGValue) -> SGValue {
    guard geomprop.dataType == SGDataType.string else {
        return SGError("Invalid geompropvalue input. Expected geomprop data type to be SGDataType.string, but got \(geomprop.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "geomprop", connection: geomprop),
        .init(name: "default", connection: default),
    ]
    if default.dataType == SGDataType.bool {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.int {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if default.dataType == SGDataType.string {
        return SGString(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for geompropvalue")
}
public func heighttonormal(_ in: SGScalar, scale: SGScalar) -> SGVector {
    guard in.dataType == SGDataType.float else {
        return SGError("Invalid heighttonormal input. Expected in data type to be SGDataType.float, but got \(in.dataType).")
    }
    guard scale.dataType == SGDataType.float else {
        return SGError("Invalid heighttonormal input. Expected scale data type to be SGDataType.float, but got \(scale.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "scale", connection: scale),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_heighttonormal_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func hsvadjust(_ in: SGColor, amount: SGVector) -> SGColor {
    guard amount.dataType == SGDataType.vector3f else {
        return SGError("Invalid hsvadjust input. Expected amount data type to be SGDataType.vector3f, but got \(amount.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for hsvadjust")
}
public func hsvtorgb(_ in: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for hsvtorgb")
}
public func ifequal(value1: SGValue, value2: SGValue, in1: SGValue, in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatB",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.half && value2.dataType == SGDataType.half && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfB",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ifequal")
}
public func ifgreater(value1: SGScalar, value2: SGScalar, in1: SGValue, in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.half && value2.dataType == SGDataType.half && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ifgreater")
}
public func ifgreatereq(value1: SGScalar, value2: SGScalar, in1: SGValue, in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.half && value2.dataType == SGDataType.half && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ifgreatereq")
}
public func image(file: TextureResource, layer: SGString, default: SGValue, texcoord: SGVector, uaddressmode: SGString, vaddressmode: SGString, filtertype: SGString, framerange: SGString, frameoffset: SGScalar, frameendaction: SGString) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard layer.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected layer data type to be SGDataType.string, but got \(layer.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard uaddressmode.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected uaddressmode data type to be SGDataType.string, but got \(uaddressmode.dataType).")
    }
    guard vaddressmode.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected vaddressmode data type to be SGDataType.string, but got \(vaddressmode.dataType).")
    }
    guard filtertype.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected filtertype data type to be SGDataType.string, but got \(filtertype.dataType).")
    }
    guard framerange.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected framerange data type to be SGDataType.string, but got \(framerange.dataType).")
    }
    guard frameoffset.dataType == SGDataType.int else {
        return SGError("Invalid image input. Expected frameoffset data type to be SGDataType.int, but got \(frameoffset.dataType).")
    }
    guard frameendaction.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected frameendaction data type to be SGDataType.string, but got \(frameendaction.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "layer", connection: layer),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "uaddressmode", connection: uaddressmode),
        .init(name: "vaddressmode", connection: vaddressmode),
        .init(name: "filtertype", connection: filtertype),
        .init(name: "framerange", connection: framerange),
        .init(name: "frameoffset", connection: frameoffset),
        .init(name: "frameendaction", connection: frameendaction),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_image_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_image_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for image")
}
public func in(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGError("Invalid in input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType).")
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGError("Invalid in input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType).")
    }
    guard mix.dataType == SGDataType.float else {
        return SGError("Invalid in input. Expected mix data type to be SGDataType.float, but got \(mix.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_in_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func inside(_ in: SGValue, mask: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mask", connection: mask),
    ]
    if in.dataType == SGDataType.color3f && mask.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && mask.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && mask.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half && mask.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for inside")
}
public func invertmatrix(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.matrix22f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    return SGError("Unsupported input data types for invertmatrix")
}
public func ln(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ln")
}
public func luminance(_ in: SGColor, lumacoeffs: SGColor) -> SGColor {
    guard lumacoeffs.dataType == SGDataType.color3f else {
        return SGError("Invalid luminance input. Expected lumacoeffs data type to be SGDataType.color3f, but got \(lumacoeffs.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "lumacoeffs", connection: lumacoeffs),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for luminance")
}
public func magnitude(_ in: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.vector2h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGError("Unsupported input data types for magnitude")
}
public func mask(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGError("Invalid mask input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType).")
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGError("Invalid mask input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType).")
    }
    guard mix.dataType == SGDataType.float else {
        return SGError("Invalid mask input. Expected mix data type to be SGDataType.float, but got \(mix.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_mask_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func matte(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGError("Invalid matte input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType).")
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGError("Invalid matte input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType).")
    }
    guard mix.dataType == SGDataType.float else {
        return SGError("Invalid matte input. Expected mix data type to be SGDataType.float, but got \(mix.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_matte_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func max(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_max_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for max")
}
public func min(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_min_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for min")
}
public func minus(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for minus")
}
public func mix(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if fg.dataType == SGDataType.vector2h && bg.dataType == SGDataType.vector2h && mix.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if fg.dataType == SGDataType.vector3h && bg.dataType == SGDataType.vector3h && mix.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if fg.dataType == SGDataType.vector4h && bg.dataType == SGDataType.vector4h && mix.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if fg.dataType == SGDataType.vector2f && bg.dataType == SGDataType.vector2f && mix.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if fg.dataType == SGDataType.vector3f && bg.dataType == SGDataType.vector3f && mix.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if fg.dataType == SGDataType.vector4f && bg.dataType == SGDataType.vector4f && mix.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for mix")
}
public func modulo(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for modulo")
}
public func multiply(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix22f && in2.dataType == SGDataType.matrix22f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in1.dataType == SGDataType.matrix33f && in2.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in1.dataType == SGDataType.matrix44f && in2.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for multiply")
}
public func noise2d(amplitude: SGValue, pivot: SGScalar, texcoord: SGVector) -> SGValue {
    guard pivot.dataType == SGDataType.float else {
        return SGError("Invalid noise2d input. Expected pivot data type to be SGDataType.float, but got \(pivot.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid noise2d input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "pivot", connection: pivot),
        .init(name: "texcoord", connection: texcoord),
    ]
    if amplitude.dataType == SGDataType.vector3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if amplitude.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for noise2d")
}
public func noise3d(amplitude: SGValue, pivot: SGScalar, position: SGVector) -> SGValue {
    guard pivot.dataType == SGDataType.float else {
        return SGError("Invalid noise3d input. Expected pivot data type to be SGDataType.float, but got \(pivot.dataType).")
    }
    guard position.dataType == SGDataType.vector3f else {
        return SGError("Invalid noise3d input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "pivot", connection: pivot),
        .init(name: "position", connection: position),
    ]
    if amplitude.dataType == SGDataType.vector3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if amplitude.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for noise3d")
}
public func normal_map_decode(_ in: SGVector) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid normal_map_decode input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_normal_map_decode",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func normal(space: SGString) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid normal input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_normal_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func normalize(_ in: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for normalize")
}
public func normalmap(_ in: SGVector, space: SGString, scale: SGValue, normal: SGVector, tangent: SGVector) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid normalmap input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid normalmap input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGError("Invalid normalmap input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType).")
    }
    guard tangent.dataType == SGDataType.vector3f else {
        return SGError("Invalid normalmap input. Expected tangent data type to be SGDataType.vector3f, but got \(tangent.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "space", connection: space),
        .init(name: "scale", connection: scale),
        .init(name: "normal", connection: normal),
        .init(name: "tangent", connection: tangent),
    ]
    if scale.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if scale.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for normalmap")
}
public func out(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGError("Invalid out input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType).")
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGError("Invalid out input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType).")
    }
    guard mix.dataType == SGDataType.float else {
        return SGError("Invalid out input. Expected mix data type to be SGDataType.float, but got \(mix.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_out_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func outside(_ in: SGValue, mask: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mask", connection: mask),
    ]
    if in.dataType == SGDataType.color3f && mask.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && mask.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && mask.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half && mask.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for outside")
}
public func over(fg: SGColor, bg: SGColor, mix: SGScalar) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGError("Invalid over input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType).")
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGError("Invalid over input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType).")
    }
    guard mix.dataType == SGDataType.float else {
        return SGError("Invalid over input. Expected mix data type to be SGDataType.float, but got \(mix.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_over_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func overlay(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for overlay")
}
public func place2d(texcoord: SGVector, pivot: SGVector, scale: SGVector, rotate: SGScalar, offset: SGVector) -> SGVector {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid place2d input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard pivot.dataType == SGDataType.vector2f else {
        return SGError("Invalid place2d input. Expected pivot data type to be SGDataType.vector2f, but got \(pivot.dataType).")
    }
    guard scale.dataType == SGDataType.vector2f else {
        return SGError("Invalid place2d input. Expected scale data type to be SGDataType.vector2f, but got \(scale.dataType).")
    }
    guard rotate.dataType == SGDataType.float else {
        return SGError("Invalid place2d input. Expected rotate data type to be SGDataType.float, but got \(rotate.dataType).")
    }
    guard offset.dataType == SGDataType.vector2f else {
        return SGError("Invalid place2d input. Expected offset data type to be SGDataType.vector2f, but got \(offset.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "pivot", connection: pivot),
        .init(name: "scale", connection: scale),
        .init(name: "rotate", connection: rotate),
        .init(name: "offset", connection: offset),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_place2d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
public func plus(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for plus")
}
public func position(space: SGString) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid position input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_position_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func power(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_power_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_power_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for power")
}
public func premult(_ in: SGColor) -> SGColor {
    guard in.dataType == SGDataType.color4f else {
        return SGError("Invalid premult input. Expected in data type to be SGDataType.color4f, but got \(in.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_premult_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func ramp4(valuetl: SGValue, valuetr: SGValue, valuebl: SGValue, valuebr: SGValue, texcoord: SGVector) -> SGValue {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid ramp4 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuetl", connection: valuetl),
        .init(name: "valuetr", connection: valuetr),
        .init(name: "valuebl", connection: valuebl),
        .init(name: "valuebr", connection: valuebr),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuetl.dataType == SGDataType.color3f && valuetr.dataType == SGDataType.color3f && valuebl.dataType == SGDataType.color3f && valuebr.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuetl.dataType == SGDataType.color4f && valuetr.dataType == SGDataType.color4f && valuebl.dataType == SGDataType.color4f && valuebr.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuetl.dataType == SGDataType.float && valuetr.dataType == SGDataType.float && valuebl.dataType == SGDataType.float && valuebr.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuetl.dataType == SGDataType.vector2f && valuetr.dataType == SGDataType.vector2f && valuebl.dataType == SGDataType.vector2f && valuebr.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuetl.dataType == SGDataType.vector3f && valuetr.dataType == SGDataType.vector3f && valuebl.dataType == SGDataType.vector3f && valuebr.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuetl.dataType == SGDataType.vector4f && valuetr.dataType == SGDataType.vector4f && valuebl.dataType == SGDataType.vector4f && valuebr.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ramp4")
}
public func ramplr(valuel: SGValue, valuer: SGValue, texcoord: SGVector) -> SGValue {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid ramplr input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuel", connection: valuel),
        .init(name: "valuer", connection: valuer),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuel.dataType == SGDataType.color3f && valuer.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuel.dataType == SGDataType.color4f && valuer.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuel.dataType == SGDataType.float && valuer.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuel.dataType == SGDataType.half && valuer.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuel.dataType == SGDataType.vector2h && valuer.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if valuel.dataType == SGDataType.vector3h && valuer.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if valuel.dataType == SGDataType.vector4h && valuer.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if valuel.dataType == SGDataType.vector2f && valuer.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuel.dataType == SGDataType.vector3f && valuer.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuel.dataType == SGDataType.vector4f && valuer.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ramplr")
}
public func ramptb(valuet: SGValue, valueb: SGValue, texcoord: SGVector) -> SGValue {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid ramptb input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuet", connection: valuet),
        .init(name: "valueb", connection: valueb),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuet.dataType == SGDataType.color3f && valueb.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuet.dataType == SGDataType.color4f && valueb.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuet.dataType == SGDataType.float && valueb.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuet.dataType == SGDataType.half && valueb.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuet.dataType == SGDataType.vector2h && valueb.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if valuet.dataType == SGDataType.vector3h && valueb.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if valuet.dataType == SGDataType.vector4h && valueb.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if valuet.dataType == SGDataType.vector2f && valueb.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuet.dataType == SGDataType.vector3f && valueb.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuet.dataType == SGDataType.vector4f && valueb.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for ramptb")
}
public func range(_ in: SGValue, inlow: SGValue, inhigh: SGValue, gamma: SGValue, outlow: SGValue, outhigh: SGValue, doclamp: SGValue) -> SGValue {
    guard doclamp.dataType == SGDataType.bool else {
        return SGError("Invalid range input. Expected doclamp data type to be SGDataType.bool, but got \(doclamp.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "inlow", connection: inlow),
        .init(name: "inhigh", connection: inhigh),
        .init(name: "gamma", connection: gamma),
        .init(name: "outlow", connection: outlow),
        .init(name: "outhigh", connection: outhigh),
        .init(name: "doclamp", connection: doclamp),
    ]
    if in.dataType == SGDataType.color3f && inlow.dataType == SGDataType.color3f && inhigh.dataType == SGDataType.color3f && gamma.dataType == SGDataType.color3f && outlow.dataType == SGDataType.color3f && outhigh.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && inlow.dataType == SGDataType.color4f && inhigh.dataType == SGDataType.color4f && gamma.dataType == SGDataType.color4f && outlow.dataType == SGDataType.color4f && outhigh.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.color4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_range_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.vector2f && inhigh.dataType == SGDataType.vector2f && gamma.dataType == SGDataType.vector2f && outlow.dataType == SGDataType.vector2f && outhigh.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.vector3f && inhigh.dataType == SGDataType.vector3f && gamma.dataType == SGDataType.vector3f && outlow.dataType == SGDataType.vector3f && outhigh.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.vector4f && inhigh.dataType == SGDataType.vector4f && gamma.dataType == SGDataType.vector4f && outlow.dataType == SGDataType.vector4f && outhigh.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for range")
}
public func cameraposition(space: SGString) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid cameraposition input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_cameraposition_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func cubeimage(file: TextureResource, default: SGValue, texcoord: SGVector, filtertype: SGString) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid cubeimage input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector3f else {
        return SGError("Invalid cubeimage input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord.dataType).")
    }
    guard filtertype.dataType == SGDataType.string else {
        return SGError("Invalid cubeimage input. Expected filtertype data type to be SGDataType.string, but got \(filtertype.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "filtertype", connection: filtertype),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_cubeimage_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for cubeimage")
}
public func fractional(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for fractional")
}
public func geometry_switch_cameraindex(mono: SGValue, left: SGValue, right: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "mono", connection: mono),
        .init(name: "left", connection: left),
        .init(name: "right", connection: right),
    ]
    if mono.dataType == SGDataType.color3f && left.dataType == SGDataType.color3f && right.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if mono.dataType == SGDataType.color4f && left.dataType == SGDataType.color4f && right.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if mono.dataType == SGDataType.float && left.dataType == SGDataType.float && right.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if mono.dataType == SGDataType.int && left.dataType == SGDataType.int && right.dataType == SGDataType.int {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if mono.dataType == SGDataType.vector2f && left.dataType == SGDataType.vector2f && right.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if mono.dataType == SGDataType.vector3f && left.dataType == SGDataType.vector3f && right.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if mono.dataType == SGDataType.vector4f && left.dataType == SGDataType.vector4f && right.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for geometry_switch_cameraindex")
}
public func image_bias(file: TextureResource, default: SGValue, texcoord: SGVector, bias: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image_bias input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image_bias input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard bias.dataType == SGDataType.float else {
        return SGError("Invalid image_bias input. Expected bias data type to be SGDataType.float, but got \(bias.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_bias input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image_bias input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image_bias input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image_bias input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_bias")
}
public func image_bias_min_lod_clamp(file: TextureResource, default: SGValue, texcoord: SGVector, bias: SGScalar, min_lod_clamp: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard bias.dataType == SGDataType.float else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected bias data type to be SGDataType.float, but got \(bias.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image_bias_min_lod_clamp input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "bias", connection: bias),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_bias_min_lod_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_bias_min_lod_clamp")
}
public func image(file: TextureResource, default: SGValue, texcoord: SGVector, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image")
}
public func image_gradient2d(file: TextureResource, default: SGValue, texcoord: SGVector, gradient2d_x: SGString, gradient2d_y: SGString, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image_gradient2d input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image_gradient2d input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard gradient2d_x.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected gradient2d_x data type to be SGDataType.string, but got \(gradient2d_x.dataType).")
    }
    guard gradient2d_y.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected gradient2d_y data type to be SGDataType.string, but got \(gradient2d_y.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image_gradient2d input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image_gradient2d input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image_gradient2d input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "gradient2d_x", connection: gradient2d_x),
        .init(name: "gradient2d_y", connection: gradient2d_y),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_gradient2d")
}
public func image_gradient2d_min_lod_clamp(file: TextureResource, default: SGValue, texcoord: SGVector, gradient2d_x: SGString, gradient2d_y: SGString, min_lod_clamp: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard gradient2d_x.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected gradient2d_x data type to be SGDataType.string, but got \(gradient2d_x.dataType).")
    }
    guard gradient2d_y.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected gradient2d_y data type to be SGDataType.string, but got \(gradient2d_y.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image_gradient2d_min_lod_clamp input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "gradient2d_x", connection: gradient2d_x),
        .init(name: "gradient2d_y", connection: gradient2d_y),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_gradient2d_min_lod_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_gradient2d_min_lod_clamp")
}
public func image_lod(file: TextureResource, default: SGValue, texcoord: SGVector, level: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image_lod input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image_lod input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard level.dataType == SGDataType.float else {
        return SGError("Invalid image_lod input. Expected level data type to be SGDataType.float, but got \(level.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_lod input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image_lod input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image_lod input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image_lod input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "level", connection: level),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_lod_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_lod")
}
public func image_min_lod_clamp(file: TextureResource, default: SGValue, texcoord: SGVector, min_lod_clamp: SGScalar, coord: SGString, s_address: SGString, t_address: SGString, border_color: SGString, mag_filter: SGString, min_filter: SGString, mip_filter: SGString, max_anisotropy: SGScalar, lod_min: SGScalar, lod_max: SGScalar) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid image_min_lod_clamp input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid image_min_lod_clamp input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard min_lod_clamp.dataType == SGDataType.float else {
        return SGError("Invalid image_min_lod_clamp input. Expected min_lod_clamp data type to be SGDataType.float, but got \(min_lod_clamp.dataType).")
    }
    guard coord.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected coord data type to be SGDataType.string, but got \(coord.dataType).")
    }
    guard s_address.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected s_address data type to be SGDataType.string, but got \(s_address.dataType).")
    }
    guard t_address.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected t_address data type to be SGDataType.string, but got \(t_address.dataType).")
    }
    guard border_color.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected border_color data type to be SGDataType.string, but got \(border_color.dataType).")
    }
    guard mag_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected mag_filter data type to be SGDataType.string, but got \(mag_filter.dataType).")
    }
    guard min_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected min_filter data type to be SGDataType.string, but got \(min_filter.dataType).")
    }
    guard mip_filter.dataType == SGDataType.string else {
        return SGError("Invalid image_min_lod_clamp input. Expected mip_filter data type to be SGDataType.string, but got \(mip_filter.dataType).")
    }
    guard max_anisotropy.dataType == SGDataType.int else {
        return SGError("Invalid image_min_lod_clamp input. Expected max_anisotropy data type to be SGDataType.int, but got \(max_anisotropy.dataType).")
    }
    guard lod_min.dataType == SGDataType.float else {
        return SGError("Invalid image_min_lod_clamp input. Expected lod_min data type to be SGDataType.float, but got \(lod_min.dataType).")
    }
    guard lod_max.dataType == SGDataType.float else {
        return SGError("Invalid image_min_lod_clamp input. Expected lod_max data type to be SGDataType.float, but got \(lod_max.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "min_lod_clamp", connection: min_lod_clamp),
        .init(name: "coord", connection: coord),
        .init(name: "s_address", connection: s_address),
        .init(name: "t_address", connection: t_address),
        .init(name: "border_color", connection: border_color),
        .init(name: "mag_filter", connection: mag_filter),
        .init(name: "min_filter", connection: min_filter),
        .init(name: "mip_filter", connection: mip_filter),
        .init(name: "max_anisotropy", connection: max_anisotropy),
        .init(name: "lod_min", connection: lod_min),
        .init(name: "lod_max", connection: lod_max),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if default.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_image_min_lod_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGError("Unsupported input data types for image_min_lod_clamp")
}
public func logical_and(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGError("Invalid logical_and input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).")
    }
    guard in2.dataType == SGDataType.bool else {
        return SGError("Invalid logical_and input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_and",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
public func logical_not(_ in: SGValue) -> SGValue {
    guard in.dataType == SGDataType.bool else {
        return SGError("Invalid logical_not input. Expected in data type to be SGDataType.bool, but got \(in.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_not",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
public func logical_or(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGError("Invalid logical_or input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).")
    }
    guard in2.dataType == SGDataType.bool else {
        return SGError("Invalid logical_or input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_or",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
public func logical_xor(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGError("Invalid logical_xor input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).")
    }
    guard in2.dataType == SGDataType.bool else {
        return SGError("Invalid logical_xor input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_xor",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
public func oneminus(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for oneminus")
}
public func reflect(_ in: SGVector, normal: SGVector) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid reflect input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGError("Invalid reflect input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "normal", connection: normal),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_reflect_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func refract(_ in: SGVector, normal: SGVector, eta: SGScalar) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid refract input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGError("Invalid refract input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType).")
    }
    guard eta.dataType == SGDataType.float else {
        return SGError("Invalid refract input. Expected eta data type to be SGDataType.float, but got \(eta.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "normal", connection: normal),
        .init(name: "eta", connection: eta),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_refract_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func step(_ in: SGValue, edge: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "edge", connection: edge),
    ]
    if in.dataType == SGDataType.color3f && edge.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && edge.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && edge.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.vector2f && edge.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && edge.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && edge.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for step")
}
public func viewdirection(space: SGString) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid viewdirection input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_viewdirection_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func remap(_ in: SGValue, inlow: SGValue, inhigh: SGValue, outlow: SGValue, outhigh: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "inlow", connection: inlow),
        .init(name: "inhigh", connection: inhigh),
        .init(name: "outlow", connection: outlow),
        .init(name: "outhigh", connection: outhigh),
    ]
    if in.dataType == SGDataType.color3f && inlow.dataType == SGDataType.color3f && inhigh.dataType == SGDataType.color3f && outlow.dataType == SGDataType.color3f && outhigh.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && inlow.dataType == SGDataType.color4f && inhigh.dataType == SGDataType.color4f && outlow.dataType == SGDataType.color4f && outhigh.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.color4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half && inlow.dataType == SGDataType.half && inhigh.dataType == SGDataType.half && outlow.dataType == SGDataType.half && outhigh.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h && inlow.dataType == SGDataType.vector2h && inhigh.dataType == SGDataType.vector2h && outlow.dataType == SGDataType.vector2h && outhigh.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector2h && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h && inlow.dataType == SGDataType.vector3h && inhigh.dataType == SGDataType.vector3h && outlow.dataType == SGDataType.vector3h && outhigh.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector3h && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h && inlow.dataType == SGDataType.vector4h && inhigh.dataType == SGDataType.vector4h && outlow.dataType == SGDataType.vector4h && outhigh.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector4h && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.vector2f && inhigh.dataType == SGDataType.vector2f && outlow.dataType == SGDataType.vector2f && outhigh.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.vector3f && inhigh.dataType == SGDataType.vector3f && outlow.dataType == SGDataType.vector3f && outhigh.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.vector4f && inhigh.dataType == SGDataType.vector4f && outlow.dataType == SGDataType.vector4f && outhigh.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for remap")
}
public func rgbtohsv(_ in: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for rgbtohsv")
}
public func rotate2d(_ in: SGVector, amount: SGScalar) -> SGVector {
    guard in.dataType == SGDataType.vector2f else {
        return SGError("Invalid rotate2d input. Expected in data type to be SGDataType.vector2f, but got \(in.dataType).")
    }
    guard amount.dataType == SGDataType.float else {
        return SGError("Invalid rotate2d input. Expected amount data type to be SGDataType.float, but got \(amount.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_rotate2d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
public func rotate3d(_ in: SGVector, amount: SGScalar, axis: SGVector) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid rotate3d input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard amount.dataType == SGDataType.float else {
        return SGError("Invalid rotate3d input. Expected amount data type to be SGDataType.float, but got \(amount.dataType).")
    }
    guard axis.dataType == SGDataType.vector3f else {
        return SGError("Invalid rotate3d input. Expected axis data type to be SGDataType.vector3f, but got \(axis.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
        .init(name: "axis", connection: axis),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_rotate3d_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func round(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_round_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_round_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for round")
}
public func safepower(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for safepower")
}
public func saturate(_ in: SGColor, amount: SGScalar, lumacoeffs: SGColor) -> SGColor {
    guard amount.dataType == SGDataType.float else {
        return SGError("Invalid saturate input. Expected amount data type to be SGDataType.float, but got \(amount.dataType).")
    }
    guard lumacoeffs.dataType == SGDataType.color3f else {
        return SGError("Invalid saturate input. Expected lumacoeffs data type to be SGDataType.color3f, but got \(lumacoeffs.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "amount", connection: amount),
        .init(name: "lumacoeffs", connection: lumacoeffs),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGError("Unsupported input data types for saturate")
}
public func screen(fg: SGValue, bg: SGValue, mix: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return SGError("Unsupported input data types for screen")
}
public func sign(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for sign")
}
public func sin(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for sin")
}
public func smoothstep(_ in: SGValue, low: SGValue, high: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "low", connection: low),
        .init(name: "high", connection: high),
    ]
    if in.dataType == SGDataType.color3f && low.dataType == SGDataType.color3f && high.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color3f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in.dataType == SGDataType.color4f && low.dataType == SGDataType.color4f && high.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.color4f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in.dataType == SGDataType.float && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half && low.dataType == SGDataType.half && high.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h && low.dataType == SGDataType.vector2h && high.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector2h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h && low.dataType == SGDataType.vector3h && high.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector3h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h && low.dataType == SGDataType.vector4h && high.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector4h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f && low.dataType == SGDataType.vector2f && high.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector2f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && low.dataType == SGDataType.vector3f && high.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector3f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && low.dataType == SGDataType.vector4f && high.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in.dataType == SGDataType.vector4f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for smoothstep")
}
public func splitlr(valuel: SGValue, valuer: SGValue, center: SGScalar, texcoord: SGVector) -> SGValue {
    guard center.dataType == SGDataType.float else {
        return SGError("Invalid splitlr input. Expected center data type to be SGDataType.float, but got \(center.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid splitlr input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuel", connection: valuel),
        .init(name: "valuer", connection: valuer),
        .init(name: "center", connection: center),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuel.dataType == SGDataType.color3f && valuer.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuel.dataType == SGDataType.color4f && valuer.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuel.dataType == SGDataType.float && valuer.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuel.dataType == SGDataType.half && valuer.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuel.dataType == SGDataType.vector2f && valuer.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuel.dataType == SGDataType.vector3f && valuer.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuel.dataType == SGDataType.vector4f && valuer.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for splitlr")
}
public func splittb(valuet: SGValue, valueb: SGValue, center: SGScalar, texcoord: SGVector) -> SGValue {
    guard center.dataType == SGDataType.float else {
        return SGError("Invalid splittb input. Expected center data type to be SGDataType.float, but got \(center.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid splittb input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuet", connection: valuet),
        .init(name: "valueb", connection: valueb),
        .init(name: "center", connection: center),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuet.dataType == SGDataType.color3f && valueb.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuet.dataType == SGDataType.color4f && valueb.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuet.dataType == SGDataType.float && valueb.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuet.dataType == SGDataType.half && valueb.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuet.dataType == SGDataType.vector2h && valueb.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if valuet.dataType == SGDataType.vector3h && valueb.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if valuet.dataType == SGDataType.vector4h && valueb.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if valuet.dataType == SGDataType.vector2f && valueb.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuet.dataType == SGDataType.vector3f && valueb.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuet.dataType == SGDataType.vector4f && valueb.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for splittb")
}
public func sqrt(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for sqrt")
}
public func subtract(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix22f && in2.dataType == SGDataType.matrix22f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in1.dataType == SGDataType.matrix22f && in2.dataType == SGDataType.float {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in1.dataType == SGDataType.matrix33f && in2.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in1.dataType == SGDataType.matrix33f && in2.dataType == SGDataType.float {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in1.dataType == SGDataType.matrix44f && in2.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in1.dataType == SGDataType.matrix44f && in2.dataType == SGDataType.float {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for subtract")
}
public func switch(_ in1: SGValue, _ in2: SGValue, _ in3: SGValue, _ in4: SGValue, _ in5: SGValue, _ in6: SGValue, _ in7: SGValue, _ in8: SGValue, _ in9: SGValue, _ in10: SGValue, which: SGScalar) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
        .init(name: "in3", connection: in3),
        .init(name: "in4", connection: in4),
        .init(name: "in5", connection: in5),
        .init(name: "in6", connection: in6),
        .init(name: "in7", connection: in7),
        .init(name: "in8", connection: in8),
        .init(name: "in9", connection: in9),
        .init(name: "in10", connection: in10),
        .init(name: "which", connection: which),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f && in3.dataType == SGDataType.color3f && in4.dataType == SGDataType.color3f && in5.dataType == SGDataType.color3f && in6.dataType == SGDataType.color3f && in7.dataType == SGDataType.color3f && in8.dataType == SGDataType.color3f && in9.dataType == SGDataType.color3f && in10.dataType == SGDataType.color3f && which.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f && in3.dataType == SGDataType.color3f && in4.dataType == SGDataType.color3f && in5.dataType == SGDataType.color3f && in6.dataType == SGDataType.color3f && in7.dataType == SGDataType.color3f && in8.dataType == SGDataType.color3f && in9.dataType == SGDataType.color3f && in10.dataType == SGDataType.color3f && which.dataType == SGDataType.int {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f && in3.dataType == SGDataType.color4f && in4.dataType == SGDataType.color4f && in5.dataType == SGDataType.color4f && in6.dataType == SGDataType.color4f && in7.dataType == SGDataType.color4f && in8.dataType == SGDataType.color4f && in9.dataType == SGDataType.color4f && in10.dataType == SGDataType.color4f && which.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f && in3.dataType == SGDataType.color4f && in4.dataType == SGDataType.color4f && in5.dataType == SGDataType.color4f && in6.dataType == SGDataType.color4f && in7.dataType == SGDataType.color4f && in8.dataType == SGDataType.color4f && in9.dataType == SGDataType.color4f && in10.dataType == SGDataType.color4f && which.dataType == SGDataType.int {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float && in3.dataType == SGDataType.float && in4.dataType == SGDataType.float && in5.dataType == SGDataType.float && in6.dataType == SGDataType.float && in7.dataType == SGDataType.float && in8.dataType == SGDataType.float && in9.dataType == SGDataType.float && in10.dataType == SGDataType.float && which.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float && in3.dataType == SGDataType.float && in4.dataType == SGDataType.float && in5.dataType == SGDataType.float && in6.dataType == SGDataType.float && in7.dataType == SGDataType.float && in8.dataType == SGDataType.float && in9.dataType == SGDataType.float && in10.dataType == SGDataType.float && which.dataType == SGDataType.int {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half && in3.dataType == SGDataType.half && in4.dataType == SGDataType.half && in5.dataType == SGDataType.half && in6.dataType == SGDataType.half && in7.dataType == SGDataType.half && in8.dataType == SGDataType.half && in9.dataType == SGDataType.half && in10.dataType == SGDataType.half && which.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half && in3.dataType == SGDataType.half && in4.dataType == SGDataType.half && in5.dataType == SGDataType.half && in6.dataType == SGDataType.half && in7.dataType == SGDataType.half && in8.dataType == SGDataType.half && in9.dataType == SGDataType.half && in10.dataType == SGDataType.half && which.dataType == SGDataType.int {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f && in3.dataType == SGDataType.vector2f && in4.dataType == SGDataType.vector2f && in5.dataType == SGDataType.vector2f && in6.dataType == SGDataType.vector2f && in7.dataType == SGDataType.vector2f && in8.dataType == SGDataType.vector2f && in9.dataType == SGDataType.vector2f && in10.dataType == SGDataType.vector2f && which.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f && in3.dataType == SGDataType.vector2f && in4.dataType == SGDataType.vector2f && in5.dataType == SGDataType.vector2f && in6.dataType == SGDataType.vector2f && in7.dataType == SGDataType.vector2f && in8.dataType == SGDataType.vector2f && in9.dataType == SGDataType.vector2f && in10.dataType == SGDataType.vector2f && which.dataType == SGDataType.int {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f && in3.dataType == SGDataType.vector3f && in4.dataType == SGDataType.vector3f && in5.dataType == SGDataType.vector3f && in6.dataType == SGDataType.vector3f && in7.dataType == SGDataType.vector3f && in8.dataType == SGDataType.vector3f && in9.dataType == SGDataType.vector3f && in10.dataType == SGDataType.vector3f && which.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f && in3.dataType == SGDataType.vector3f && in4.dataType == SGDataType.vector3f && in5.dataType == SGDataType.vector3f && in6.dataType == SGDataType.vector3f && in7.dataType == SGDataType.vector3f && in8.dataType == SGDataType.vector3f && in9.dataType == SGDataType.vector3f && in10.dataType == SGDataType.vector3f && which.dataType == SGDataType.int {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f && in3.dataType == SGDataType.vector4f && in4.dataType == SGDataType.vector4f && in5.dataType == SGDataType.vector4f && in6.dataType == SGDataType.vector4f && in7.dataType == SGDataType.vector4f && in8.dataType == SGDataType.vector4f && in9.dataType == SGDataType.vector4f && in10.dataType == SGDataType.vector4f && which.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f && in3.dataType == SGDataType.vector4f && in4.dataType == SGDataType.vector4f && in5.dataType == SGDataType.vector4f && in6.dataType == SGDataType.vector4f && in7.dataType == SGDataType.vector4f && in8.dataType == SGDataType.vector4f && in9.dataType == SGDataType.vector4f && in10.dataType == SGDataType.vector4f && which.dataType == SGDataType.int {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for switch")
}
public func tan(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for tan")
}
public func tangent(space: SGString, index: SGScalar) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid tangent input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    guard index.dataType == SGDataType.int else {
        return SGError("Invalid tangent input. Expected index data type to be SGDataType.int, but got \(index.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
        .init(name: "index", connection: index),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_tangent_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func texcoord(index: SGScalar) -> SGVector {
    guard index.dataType == SGDataType.int else {
        return SGError("Invalid texcoord input. Expected index data type to be SGDataType.int, but got \(index.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "index", connection: index),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_texcoord_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_texcoord_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func tiledimage(file: TextureResource, default: SGValue, texcoord: SGVector, uvtiling: SGVector, uvoffset: SGVector, realworldimagesize: SGVector, realworldtilesize: SGVector, filtertype: SGString, framerange: SGString, frameoffset: SGScalar, frameendaction: SGString) -> SGValue {
    guard file.dataType == SGDataType.asset else {
        return SGError("Invalid tiledimage input. Expected file data type to be SGDataType.asset, but got \(file.dataType).")
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid tiledimage input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard uvtiling.dataType == SGDataType.vector2f else {
        return SGError("Invalid tiledimage input. Expected uvtiling data type to be SGDataType.vector2f, but got \(uvtiling.dataType).")
    }
    guard uvoffset.dataType == SGDataType.vector2f else {
        return SGError("Invalid tiledimage input. Expected uvoffset data type to be SGDataType.vector2f, but got \(uvoffset.dataType).")
    }
    guard realworldimagesize.dataType == SGDataType.vector2f else {
        return SGError("Invalid tiledimage input. Expected realworldimagesize data type to be SGDataType.vector2f, but got \(realworldimagesize.dataType).")
    }
    guard realworldtilesize.dataType == SGDataType.vector2f else {
        return SGError("Invalid tiledimage input. Expected realworldtilesize data type to be SGDataType.vector2f, but got \(realworldtilesize.dataType).")
    }
    guard filtertype.dataType == SGDataType.string else {
        return SGError("Invalid tiledimage input. Expected filtertype data type to be SGDataType.string, but got \(filtertype.dataType).")
    }
    guard framerange.dataType == SGDataType.string else {
        return SGError("Invalid tiledimage input. Expected framerange data type to be SGDataType.string, but got \(framerange.dataType).")
    }
    guard frameoffset.dataType == SGDataType.int else {
        return SGError("Invalid tiledimage input. Expected frameoffset data type to be SGDataType.int, but got \(frameoffset.dataType).")
    }
    guard frameendaction.dataType == SGDataType.string else {
        return SGError("Invalid tiledimage input. Expected frameendaction data type to be SGDataType.string, but got \(frameendaction.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: default),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "uvtiling", connection: uvtiling),
        .init(name: "uvoffset", connection: uvoffset),
        .init(name: "realworldimagesize", connection: realworldimagesize),
        .init(name: "realworldtilesize", connection: realworldtilesize),
        .init(name: "filtertype", connection: filtertype),
        .init(name: "framerange", connection: framerange),
        .init(name: "frameoffset", connection: frameoffset),
        .init(name: "frameendaction", connection: frameendaction),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.half {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for tiledimage")
}
public func time(fps: SGScalar) -> SGScalar {
    guard fps.dataType == SGDataType.float else {
        return SGError("Invalid time input. Expected fps data type to be SGDataType.float, but got \(fps.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fps", connection: fps),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_time_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
public func transformmatrix(_ in: SGVector, mat: SGValue) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mat", connection: mat),
    ]
    if in.dataType == SGDataType.vector2f && mat.dataType == SGDataType.matrix22f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in.dataType == SGDataType.vector3f && mat.dataType == SGDataType.matrix33f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in.dataType == SGDataType.vector4f && mat.dataType == SGDataType.matrix44f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for transformmatrix")
}
public func transformmatrix_vector2M3(_ in: SGVector, mat: SGValue) -> SGVector {
    guard in.dataType == SGDataType.vector2f else {
        return SGError("Invalid transformmatrix_vector2M3 input. Expected in data type to be SGDataType.vector2f, but got \(in.dataType).")
    }
    guard mat.dataType == SGDataType.matrix33f else {
        return SGError("Invalid transformmatrix_vector2M3 input. Expected mat data type to be SGDataType.matrix33f, but got \(mat.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mat", connection: mat),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformmatrix_vector2M3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
public func transformmatrix_vector3M4(_ in: SGVector, mat: SGValue) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid transformmatrix_vector3M4 input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard mat.dataType == SGDataType.matrix44f else {
        return SGError("Invalid transformmatrix_vector3M4 input. Expected mat data type to be SGDataType.matrix44f, but got \(mat.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "mat", connection: mat),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformmatrix_vector3M4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transformnormal(_ in: SGVector, fromspace: SGString, tospace: SGString) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid transformnormal input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard fromspace.dataType == SGDataType.string else {
        return SGError("Invalid transformnormal input. Expected fromspace data type to be SGDataType.string, but got \(fromspace.dataType).")
    }
    guard tospace.dataType == SGDataType.string else {
        return SGError("Invalid transformnormal input. Expected tospace data type to be SGDataType.string, but got \(tospace.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "fromspace", connection: fromspace),
        .init(name: "tospace", connection: tospace),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformnormal_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transformpoint(_ in: SGVector, fromspace: SGString, tospace: SGString) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid transformpoint input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard fromspace.dataType == SGDataType.string else {
        return SGError("Invalid transformpoint input. Expected fromspace data type to be SGDataType.string, but got \(fromspace.dataType).")
    }
    guard tospace.dataType == SGDataType.string else {
        return SGError("Invalid transformpoint input. Expected tospace data type to be SGDataType.string, but got \(tospace.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "fromspace", connection: fromspace),
        .init(name: "tospace", connection: tospace),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformpoint_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transformvector(_ in: SGVector, fromspace: SGString, tospace: SGString) -> SGVector {
    guard in.dataType == SGDataType.vector3f else {
        return SGError("Invalid transformvector input. Expected in data type to be SGDataType.vector3f, but got \(in.dataType).")
    }
    guard fromspace.dataType == SGDataType.string else {
        return SGError("Invalid transformvector input. Expected fromspace data type to be SGDataType.string, but got \(fromspace.dataType).")
    }
    guard tospace.dataType == SGDataType.string else {
        return SGError("Invalid transformvector input. Expected tospace data type to be SGDataType.string, but got \(tospace.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
        .init(name: "fromspace", connection: fromspace),
        .init(name: "tospace", connection: tospace),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformvector_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transpose(_ in: SGValue) -> SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    if in.dataType == SGDataType.matrix22f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix22f)])))
    }
    if in.dataType == SGDataType.matrix33f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix33f)])))
    }
    if in.dataType == SGDataType.matrix44f {
        return SGValue(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix44f)])))
    }
    return SGError("Unsupported input data types for transpose")
}
public func triplanarprojection(filex: TextureResource, filey: TextureResource, filez: TextureResource, layerx: SGString, layery: SGString, layerz: SGString, default: SGValue, position: SGVector, normal: SGVector, filtertype: SGString, framerange: SGString, frameoffset: SGScalar, frameendaction: SGString) -> SGValue {
    guard filex.dataType == SGDataType.asset else {
        return SGError("Invalid triplanarprojection input. Expected filex data type to be SGDataType.asset, but got \(filex.dataType).")
    }
    guard filey.dataType == SGDataType.asset else {
        return SGError("Invalid triplanarprojection input. Expected filey data type to be SGDataType.asset, but got \(filey.dataType).")
    }
    guard filez.dataType == SGDataType.asset else {
        return SGError("Invalid triplanarprojection input. Expected filez data type to be SGDataType.asset, but got \(filez.dataType).")
    }
    guard layerx.dataType == SGDataType.string else {
        return SGError("Invalid triplanarprojection input. Expected layerx data type to be SGDataType.string, but got \(layerx.dataType).")
    }
    guard layery.dataType == SGDataType.string else {
        return SGError("Invalid triplanarprojection input. Expected layery data type to be SGDataType.string, but got \(layery.dataType).")
    }
    guard layerz.dataType == SGDataType.string else {
        return SGError("Invalid triplanarprojection input. Expected layerz data type to be SGDataType.string, but got \(layerz.dataType).")
    }
    guard position.dataType == SGDataType.vector3f else {
        return SGError("Invalid triplanarprojection input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType).")
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGError("Invalid triplanarprojection input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType).")
    }
    guard filtertype.dataType == SGDataType.string else {
        return SGError("Invalid triplanarprojection input. Expected filtertype data type to be SGDataType.string, but got \(filtertype.dataType).")
    }
    guard framerange.dataType == SGDataType.string else {
        return SGError("Invalid triplanarprojection input. Expected framerange data type to be SGDataType.string, but got \(framerange.dataType).")
    }
    guard frameoffset.dataType == SGDataType.int else {
        return SGError("Invalid triplanarprojection input. Expected frameoffset data type to be SGDataType.int, but got \(frameoffset.dataType).")
    }
    guard frameendaction.dataType == SGDataType.string else {
        return SGError("Invalid triplanarprojection input. Expected frameendaction data type to be SGDataType.string, but got \(frameendaction.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "filex", connection: filex),
        .init(name: "filey", connection: filey),
        .init(name: "filez", connection: filez),
        .init(name: "layerx", connection: layerx),
        .init(name: "layery", connection: layery),
        .init(name: "layerz", connection: layerz),
        .init(name: "default", connection: default),
        .init(name: "position", connection: position),
        .init(name: "normal", connection: normal),
        .init(name: "filtertype", connection: filtertype),
        .init(name: "framerange", connection: framerange),
        .init(name: "frameoffset", connection: frameoffset),
        .init(name: "frameendaction", connection: frameendaction),
    ]
    if default.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if default.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if default.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if default.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if default.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if default.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGError("Unsupported input data types for triplanarprojection")
}
public func unpremult(_ in: SGColor) -> SGColor {
    guard in.dataType == SGDataType.color4f else {
        return SGError("Invalid unpremult input. Expected in data type to be SGDataType.color4f, but got \(in.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_unpremult_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func updirection(space: SGString) -> SGVector {
    guard space.dataType == SGDataType.string else {
        return SGError("Invalid updirection input. Expected space data type to be SGDataType.string, but got \(space.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "space", connection: space),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_updirection_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func worleynoise2d(texcoord: SGVector, jitter: SGScalar) -> SGValue {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGError("Invalid worleynoise2d input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType).")
    }
    guard jitter.dataType == SGDataType.float else {
        return SGError("Invalid worleynoise2d input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "jitter", connection: jitter),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func worleynoise3d(position: SGVector, jitter: SGScalar) -> SGValue {
    guard position.dataType == SGDataType.vector3f else {
        return SGError("Invalid worleynoise3d input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType).")
    }
    guard jitter.dataType == SGDataType.float else {
        return SGError("Invalid worleynoise3d input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType).")
    }
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
        .init(name: "jitter", connection: jitter),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
