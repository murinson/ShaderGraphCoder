// Autogenerated by opgen.py
import Foundation
import simd

public enum SGSamplerAddressMode: String, CaseIterable {
    case clampToBorder = "clamp_to_border"
    case clampToEdge = "clamp_to_edge"
    case clampToZero = "clamp_to_zero"
    case mirroredRepeat = "mirrored_repeat"
    case repeated = "repeat"
}

public enum SGSamplerBorderColor: String, CaseIterable {
    case opaqueBlack = "opaque_black"
    case opaqueWhite = "opaque_white"
    case transparentBlack = "transparent_black"
}

public enum SGSamplerMinMagFilter: String, CaseIterable {
    case linear = "linear"
    case nearest = "nearest"
}

public enum SGSamplerMipFilter: String, CaseIterable {
    case linear = "linear"
    case nearest = "nearest"
    case none = "none"
}

public enum SGSamplerAddressModeWithoutRepeat: String, CaseIterable {
    case clampToBorder = "clamp_to_border"
    case clampToEdge = "clamp_to_edge"
    case clampToZero = "clamp_to_zero"
}

public enum SGSpace: String, CaseIterable {
    case model = "model"
    case object = "object"
    case tangent = "tangent"
    case world = "world"
}

public enum SGBlurFilterType: String, CaseIterable {
    case box = "box"
    case gaussian = "gaussian"
}

public enum SGImageAddressMode: String, CaseIterable {
    case clamp = "clamp"
    case constant = "constant"
    case mirror = "mirror"
    case periodic = "periodic"
}

public enum SGFilterType: String, CaseIterable {
    case closest = "closest"
    case cubic = "cubic"
    case linear = "linear"
}

public enum SGNormalSpace: String, CaseIterable {
    case object = "object"
    case tangent = "tangent"
}

public enum SGTransformSpace: String, CaseIterable {
    case model = "model"
    case object = "object"
    case unspecified = "unspecified"
    case world = "world"
}

/// Abs
public func abs<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in abs(in1: \(in1.dataType))", values: [in1]))
}
/// Acos
public func acos<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in acos(in1: \(in1.dataType))", values: [in1]))
}
/// Add
public func add<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.matrix2d.matches(in1) && SGDataType.matrix2d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix2d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix2d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix2d.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix2d, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix3d.matches(in1) && SGDataType.matrix3d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix3d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix3d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix3d.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix3d, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix4d.matches(in1) && SGDataType.matrix4d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix4d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix4d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if SGDataType.matrix4d.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix4d, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in add(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Ambient Occlusion
public func ambientOcclusion(coneangle: SGScalar? = nil, maxdistance: SGScalar? = nil) -> SGScalar {
    guard SGDataType.float.matches(coneangle) else {
        return SGScalar(source: .error("Invalid ambientOcclusion input. Expected coneangle data type to be SGDataType.float, but got \(coneangle?.dataType.rawValue ?? "nil").", values: [coneangle]))
    }
    guard SGDataType.float.matches(maxdistance) else {
        return SGScalar(source: .error("Invalid ambientOcclusion input. Expected maxdistance data type to be SGDataType.float, but got \(maxdistance?.dataType.rawValue ?? "nil").", values: [maxdistance]))
    }
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_ambientocclusion_float",
        inputs: [
            .init(name: "coneangle", dataType: SGDataType.float, connection: coneangle),
            .init(name: "maxdistance", dataType: SGDataType.float, connection: maxdistance),
        ],
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Asin
public func asin<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in asin(in1: \(in1.dataType))", values: [in1]))
}
/// Atan2
public func atan2<T>(iny: T, inx: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(iny) && SGDataType.float.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_float",
            inputs: [
                .init(name: "iny", dataType: SGDataType.float, connection: iny),
                .init(name: "inx", dataType: SGDataType.float, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(iny) && SGDataType.half.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half",
            inputs: [
                .init(name: "iny", dataType: SGDataType.half, connection: iny),
                .init(name: "inx", dataType: SGDataType.half, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(iny) && SGDataType.vector2h.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half2",
            inputs: [
                .init(name: "iny", dataType: SGDataType.vector2h, connection: iny),
                .init(name: "inx", dataType: SGDataType.vector2h, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(iny) && SGDataType.vector3h.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half3",
            inputs: [
                .init(name: "iny", dataType: SGDataType.vector3h, connection: iny),
                .init(name: "inx", dataType: SGDataType.vector3h, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(iny) && SGDataType.vector4h.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half4",
            inputs: [
                .init(name: "iny", dataType: SGDataType.vector4h, connection: iny),
                .init(name: "inx", dataType: SGDataType.vector4h, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(iny) && SGDataType.vector2f.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector2",
            inputs: [
                .init(name: "iny", dataType: SGDataType.vector2f, connection: iny),
                .init(name: "inx", dataType: SGDataType.vector2f, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(iny) && SGDataType.vector3f.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector3",
            inputs: [
                .init(name: "iny", dataType: SGDataType.vector3f, connection: iny),
                .init(name: "inx", dataType: SGDataType.vector3f, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(iny) && SGDataType.vector4f.matches(inx) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector4",
            inputs: [
                .init(name: "iny", dataType: SGDataType.vector4f, connection: iny),
                .init(name: "inx", dataType: SGDataType.vector4f, connection: inx),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in atan2(iny: \(iny.dataType), inx: \(inx.dataType))", values: [iny, inx]))
}
/// Blur
public func blur<T>(_ in1: T, size: SGScalar? = nil, filtertype: SGBlurFilterType = SGBlurFilterType.box) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "size", dataType: SGDataType.float, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "size", dataType: SGDataType.float, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "size", dataType: SGDataType.float, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
                .init(name: "size", dataType: SGDataType.half, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "size", dataType: SGDataType.float, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "size", dataType: SGDataType.float, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(size) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "size", dataType: SGDataType.float, connection: size),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in blur(in1: \(in1.dataType), size: \(size?.dataType.rawValue ?? "nil"))", values: [in1, size]))
}
/// Burn
public func burn<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in burn(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Ceiling
public func ceil<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ceil(in1: \(in1.dataType))", values: [in1]))
}
/// Cellular Noise 2D
public func cellNoise2D(texcoord: SGVector? = nil) -> SGScalar {
    guard SGDataType.vector2f.matches(texcoord) else {
        return SGScalar(source: .error("Invalid cellNoise2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_cellnoise2d_float",
        inputs: [
            .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
        ],
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Cellular Noise 3D
public func cellNoise3D(position: SGVector? = nil) -> SGScalar {
    guard SGDataType.vector3f.matches(position) else {
        return SGScalar(source: .error("Invalid cellNoise3D input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_cellnoise3d_float",
        inputs: [
            .init(name: "position", dataType: SGDataType.vector3f, connection: position),
        ],
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Clamp
public func clamp<T>(_ in1: T, min: SGNumeric, max: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(min) && SGDataType.color3f.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "low", dataType: SGDataType.color3f, connection: min),
                .init(name: "high", dataType: SGDataType.color3f, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(min) && SGDataType.color4f.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "low", dataType: SGDataType.color4f, connection: min),
                .init(name: "high", dataType: SGDataType.color4f, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(min) && SGDataType.half.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
                .init(name: "low", dataType: SGDataType.half, connection: min),
                .init(name: "high", dataType: SGDataType.half, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.vector2h.matches(min) && SGDataType.vector2h.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "low", dataType: SGDataType.vector2h, connection: min),
                .init(name: "high", dataType: SGDataType.vector2h, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(min) && SGDataType.vector3h.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "low", dataType: SGDataType.vector3h, connection: min),
                .init(name: "high", dataType: SGDataType.vector3h, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.vector4h.matches(min) && SGDataType.vector4h.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "low", dataType: SGDataType.vector4h, connection: min),
                .init(name: "high", dataType: SGDataType.vector4h, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(min) && SGDataType.vector2f.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "low", dataType: SGDataType.vector2f, connection: min),
                .init(name: "high", dataType: SGDataType.vector2f, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(min) && SGDataType.vector3f.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "low", dataType: SGDataType.vector3f, connection: min),
                .init(name: "high", dataType: SGDataType.vector3f, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(min) && SGDataType.vector4f.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "low", dataType: SGDataType.vector4f, connection: min),
                .init(name: "high", dataType: SGDataType.vector4f, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(min) && SGDataType.float.matches(max) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: min),
                .init(name: "high", dataType: SGDataType.float, connection: max),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in clamp(in1: \(in1.dataType), min: \(min.dataType), max: \(max.dataType))", values: [in1, min, max]))
}
/// Contrast
public func contrast<T>(_ in1: T, amount: SGNumeric, pivot: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(amount) && SGDataType.color3f.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "amount", dataType: SGDataType.color3f, connection: amount),
                .init(name: "pivot", dataType: SGDataType.color3f, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(amount) && SGDataType.float.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(amount) && SGDataType.color4f.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "amount", dataType: SGDataType.color4f, connection: amount),
                .init(name: "pivot", dataType: SGDataType.color4f, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(amount) && SGDataType.float.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(amount) && SGDataType.float.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(amount) && SGDataType.vector2f.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "amount", dataType: SGDataType.vector2f, connection: amount),
                .init(name: "pivot", dataType: SGDataType.vector2f, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(amount) && SGDataType.float.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(amount) && SGDataType.vector3f.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "amount", dataType: SGDataType.vector3f, connection: amount),
                .init(name: "pivot", dataType: SGDataType.vector3f, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(amount) && SGDataType.float.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(amount) && SGDataType.vector4f.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "amount", dataType: SGDataType.vector4f, connection: amount),
                .init(name: "pivot", dataType: SGDataType.vector4f, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(amount) && SGDataType.float.matches(pivot) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in contrast(in1: \(in1.dataType), amount: \(amount.dataType), pivot: \(pivot.dataType))", values: [in1, amount, pivot]))
}
/// Cos
public func cos<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in cos(in1: \(in1.dataType))", values: [in1]))
}
/// Cross Product
public func cross(_ in1: SGVector, _ in2: SGVector) -> SGVector {
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(in2) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_half3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGVector(source: .error("Unsupported input data types in cross(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Determinant
public func determinant(_ in1: SGMatrix) -> SGScalar {
    if SGDataType.matrix2d.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix22",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix2d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.matrix3d.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix33",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix3d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.matrix4d.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix44",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix4d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types in determinant(in1: \(in1.dataType))", values: [in1]))
}
/// Difference
public func difference<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in difference(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Disjoint Over
public func disjointover(fg: SGColor? = nil, bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
    guard SGDataType.color4f.matches(fg) else {
        return SGColor(source: .error("Invalid disjointover input. Expected fg data type to be SGDataType.color4f, but got \(fg?.dataType.rawValue ?? "nil").", values: [fg]))
    }
    guard SGDataType.color4f.matches(bg) else {
        return SGColor(source: .error("Invalid disjointover input. Expected bg data type to be SGDataType.color4f, but got \(bg?.dataType.rawValue ?? "nil").", values: [bg]))
    }
    guard SGDataType.float.matches(mix) else {
        return SGColor(source: .error("Invalid disjointover input. Expected mix data type to be SGDataType.float, but got \(mix?.dataType.rawValue ?? "nil").", values: [mix]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_disjointover_color4",
        inputs: [
            .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
            .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
            .init(name: "mix", dataType: SGDataType.float, connection: mix),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Divide
public func divide<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.matrix2d.matches(in1) && SGDataType.matrix2d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix22",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix2d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix2d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix3d.matches(in1) && SGDataType.matrix3d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix33",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix3d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix3d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix4d.matches(in1) && SGDataType.matrix4d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix44",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix4d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix4d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in divide(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Dodge
public func dodge<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in dodge(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Dot Product
public func dot(_ in1: SGVector, _ in2: SGVector) -> SGScalar {
    if SGDataType.vector2h.matches(in1) && SGDataType.vector2h.matches(in2) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(in2) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.vector4h.matches(in2) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types in dot(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Exp
public func exp<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in exp(in1: \(in1.dataType))", values: [in1]))
}
/// Extract
public func extract(_ in1: SGSIMD, index: Int = 0) -> SGScalar {
    if SGDataType.color3f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "index", dataType: SGDataType.int, connection: SGScalar(source: .constant(.int(index)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.color4f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "index", dataType: SGDataType.int, connection: SGScalar(source: .constant(.int(index)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "index", dataType: SGDataType.int, connection: SGScalar(source: .constant(.int(index)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "index", dataType: SGDataType.int, connection: SGScalar(source: .constant(.int(index)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "index", dataType: SGDataType.int, connection: SGScalar(source: .constant(.int(index)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types in extract(in1: \(in1.dataType))", values: [in1]))
}
/// Floor
public func floor<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in floor(in1: \(in1.dataType))", values: [in1]))
}
/// Fractional
public func fract<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in fract(in1: \(in1.dataType))", values: [in1]))
}
/// Fractal Noise 3D
public func fractal3D(amplitude: SGNumeric, octaves: SGScalar? = nil, lacunarity: SGScalar? = nil, diminish: SGScalar? = nil, position: SGVector? = nil) -> SGNumeric {
    guard SGDataType.int.matches(octaves) else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected octaves data type to be SGDataType.int, but got \(octaves?.dataType.rawValue ?? "nil").", values: [octaves]))
    }
    guard SGDataType.float.matches(lacunarity) else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected lacunarity data type to be SGDataType.float, but got \(lacunarity?.dataType.rawValue ?? "nil").", values: [lacunarity]))
    }
    guard SGDataType.float.matches(diminish) else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected diminish data type to be SGDataType.float, but got \(diminish?.dataType.rawValue ?? "nil").", values: [diminish]))
    }
    guard SGDataType.vector3f.matches(position) else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    if SGDataType.vector3f.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector3f, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.vector4f.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector4f, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_float",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector2f, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector3f, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector4f, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "octaves", dataType: SGDataType.int, connection: octaves),
                .init(name: "lacunarity", dataType: SGDataType.float, connection: lacunarity),
                .init(name: "diminish", dataType: SGDataType.float, connection: diminish),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGNumeric(source: .error("Unsupported input data types in fractal3D(amplitude: \(amplitude.dataType))", values: [amplitude]))
}
/// Camera Index Switch
public func geometrySwitchCameraindex<T>(mono: T, left: T, right: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(mono) && SGDataType.color3f.matches(left) && SGDataType.color3f.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color3",
            inputs: [
                .init(name: "mono", dataType: SGDataType.color3f, connection: mono),
                .init(name: "left", dataType: SGDataType.color3f, connection: left),
                .init(name: "right", dataType: SGDataType.color3f, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(mono) && SGDataType.color4f.matches(left) && SGDataType.color4f.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color4",
            inputs: [
                .init(name: "mono", dataType: SGDataType.color4f, connection: mono),
                .init(name: "left", dataType: SGDataType.color4f, connection: left),
                .init(name: "right", dataType: SGDataType.color4f, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(mono) && SGDataType.float.matches(left) && SGDataType.float.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_float",
            inputs: [
                .init(name: "mono", dataType: SGDataType.float, connection: mono),
                .init(name: "left", dataType: SGDataType.float, connection: left),
                .init(name: "right", dataType: SGDataType.float, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.int.matches(mono) && SGDataType.int.matches(left) && SGDataType.int.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_integer",
            inputs: [
                .init(name: "mono", dataType: SGDataType.int, connection: mono),
                .init(name: "left", dataType: SGDataType.int, connection: left),
                .init(name: "right", dataType: SGDataType.int, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if SGDataType.vector2f.matches(mono) && SGDataType.vector2f.matches(left) && SGDataType.vector2f.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector2",
            inputs: [
                .init(name: "mono", dataType: SGDataType.vector2f, connection: mono),
                .init(name: "left", dataType: SGDataType.vector2f, connection: left),
                .init(name: "right", dataType: SGDataType.vector2f, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(mono) && SGDataType.vector3f.matches(left) && SGDataType.vector3f.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector3",
            inputs: [
                .init(name: "mono", dataType: SGDataType.vector3f, connection: mono),
                .init(name: "left", dataType: SGDataType.vector3f, connection: left),
                .init(name: "right", dataType: SGDataType.vector3f, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(mono) && SGDataType.vector4f.matches(left) && SGDataType.vector4f.matches(right) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector4",
            inputs: [
                .init(name: "mono", dataType: SGDataType.vector4f, connection: mono),
                .init(name: "left", dataType: SGDataType.vector4f, connection: left),
                .init(name: "right", dataType: SGDataType.vector4f, connection: right),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in geometrySwitchCameraindex(mono: \(mono.dataType), left: \(left.dataType), right: \(right.dataType))", values: [mono, left, right]))
}
/// Geometric Property
public func geompropvalue<T>(geomprop: String = "", defaultValue: T) -> T where T: SGValue {
    if SGDataType.bool.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_boolean",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.bool, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color3",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color4",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_float",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.float, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_half",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.half, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.int.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_integer",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.int, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if SGDataType.string.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_string",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.string, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if SGDataType.vector2f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector2",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.vector2f, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector3",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.vector3f, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector4",
            inputs: [
                .init(name: "geomprop", dataType: SGDataType.string, connection: SGString(source: .constant(.string(geomprop)))),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in geompropvalue(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Height To Normal
public func heightToNormal(_ in1: SGScalar, scale: SGScalar? = nil) -> SGVector {
    guard SGDataType.float.matches(in1) else {
        return SGVector(source: .error("Invalid heightToNormal input. Expected in1 data type to be SGDataType.float, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.float.matches(scale) else {
        return SGVector(source: .error("Invalid heightToNormal input. Expected scale data type to be SGDataType.float, but got \(scale?.dataType.rawValue ?? "nil").", values: [scale]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_heighttonormal_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.float, connection: in1),
            .init(name: "scale", dataType: SGDataType.float, connection: scale),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// HSV Adjust
public func hsvAdjust(_ in1: SGColor, amount: SGVector? = nil) -> SGColor {
    guard SGDataType.vector3f.matches(amount) else {
        return SGColor(source: .error("Invalid hsvAdjust input. Expected amount data type to be SGDataType.vector3f, but got \(amount?.dataType.rawValue ?? "nil").", values: [amount]))
    }
    if SGDataType.color3f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "amount", dataType: SGDataType.vector3f, connection: amount),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "amount", dataType: SGDataType.vector3f, connection: amount),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types in hsvAdjust(in1: \(in1.dataType))", values: [in1]))
}
/// HSV to RGB
public func hsvToRGB(_ in1: SGColor) -> SGColor {
    if SGDataType.color3f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types in hsvToRGB(in1: \(in1.dataType))", values: [in1]))
}
/// If Equal
public func ifEqual<T>(_ value1: SGValue, _ value2: SGValue, trueResult: T, falseResult: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_float",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatB",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatI",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(value1) && SGDataType.half.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half",
            inputs: [
                .init(name: "value1", dataType: SGDataType.half, connection: value1),
                .init(name: "value2", dataType: SGDataType.half, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfB",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfI",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.bool.matches(value1) && SGDataType.bool.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4B",
            inputs: [
                .init(name: "value1", dataType: SGDataType.bool, connection: value1),
                .init(name: "value2", dataType: SGDataType.bool, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ifEqual(value1: \(value1.dataType), value2: \(value2.dataType), trueResult: \(trueResult.dataType), falseResult: \(falseResult.dataType))", values: [value1, value2, trueResult, falseResult]))
}
/// If Greater
public func ifGreater<T>(_ value1: SGScalar, _ value2: SGScalar, trueResult: T, falseResult: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_float",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_floatI",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(value1) && SGDataType.half.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half",
            inputs: [
                .init(name: "value1", dataType: SGDataType.half, connection: value1),
                .init(name: "value2", dataType: SGDataType.half, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_halfI",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ifGreater(value1: \(value1.dataType), value2: \(value2.dataType), trueResult: \(trueResult.dataType), falseResult: \(falseResult.dataType))", values: [value1, value2, trueResult, falseResult]))
}
/// If Greater Or Equal
public func ifGreaterOrEqual<T>(_ value1: SGScalar, _ value2: SGScalar, trueResult: T, falseResult: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.color3f.matches(trueResult) && SGDataType.color3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.color3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.color4f.matches(trueResult) && SGDataType.color4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.color4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.color4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_float",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.float.matches(trueResult) && SGDataType.float.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_floatI",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.float, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.float, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(value1) && SGDataType.half.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half",
            inputs: [
                .init(name: "value1", dataType: SGDataType.half, connection: value1),
                .init(name: "value2", dataType: SGDataType.half, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector2h.matches(trueResult) && SGDataType.vector2h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector3h.matches(trueResult) && SGDataType.vector3h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector4h.matches(trueResult) && SGDataType.vector4h.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4h, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.half.matches(trueResult) && SGDataType.half.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_halfI",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.half, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.half, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector2f.matches(trueResult) && SGDataType.vector2f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector2f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector3f.matches(trueResult) && SGDataType.vector3f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector3f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.float.matches(value1) && SGDataType.float.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4",
            inputs: [
                .init(name: "value1", dataType: SGDataType.float, connection: value1),
                .init(name: "value2", dataType: SGDataType.float, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.int.matches(value1) && SGDataType.int.matches(value2) && SGDataType.vector4f.matches(trueResult) && SGDataType.vector4f.matches(falseResult) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4I",
            inputs: [
                .init(name: "value1", dataType: SGDataType.int, connection: value1),
                .init(name: "value2", dataType: SGDataType.int, connection: value2),
                .init(name: "in1", dataType: SGDataType.vector4f, connection: trueResult),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: falseResult),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ifGreaterOrEqual(value1: \(value1.dataType), value2: \(value2.dataType), trueResult: \(trueResult.dataType), falseResult: \(falseResult.dataType))", values: [value1, value2, trueResult, falseResult]))
}
/// Image
public func image<T>(file: SGTexture, defaultValue: T, texcoord: SGVector? = nil, uaddressmode: SGImageAddressMode = SGImageAddressMode.periodic, vaddressmode: SGImageAddressMode = SGImageAddressMode.periodic, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid image input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid image input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_float",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.float, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_half",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.half, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector2",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector2f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
                .init(name: "vaddressmode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in image(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Inside
public func inside<T>(_ in1: T, mask: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "mask", dataType: SGDataType.float, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "mask", dataType: SGDataType.float, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "mask", dataType: SGDataType.float, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
                .init(name: "mask", dataType: SGDataType.half, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in inside(in1: \(in1.dataType), mask: \(mask?.dataType.rawValue ?? "nil"))", values: [in1, mask]))
}
/// Invert Matrix
public func invertMatrix(_ in1: SGMatrix) -> SGMatrix {
    if SGDataType.matrix2d.matches(in1) {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix22",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix2d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix3d.matches(in1) {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix33",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix3d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix4d.matches(in1) {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix44",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix4d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    return SGMatrix(source: .error("Unsupported input data types in invertMatrix(in1: \(in1.dataType))", values: [in1]))
}
/// Magnitude
public func length(_ in1: SGVector) -> SGScalar {
    if SGDataType.vector2h.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types in length(in1: \(in1.dataType))", values: [in1]))
}
/// Natural Log
public func log<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in log(in1: \(in1.dataType))", values: [in1]))
}
/// And
public func logicalAnd(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    guard SGDataType.bool.matches(in1) else {
        return SGValue(source: .error("Invalid logicalAnd input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.bool.matches(in2) else {
        return SGValue(source: .error("Invalid logicalAnd input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType).", values: [in2]))
    }
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_and",
        inputs: [
            .init(name: "in1", dataType: SGDataType.bool, connection: in1),
            .init(name: "in2", dataType: SGDataType.bool, connection: in2),
        ],
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// Not
public func logicalNot(_ in1: SGValue) -> SGValue {
    guard SGDataType.bool.matches(in1) else {
        return SGValue(source: .error("Invalid logicalNot input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).", values: [in1]))
    }
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_not",
        inputs: [
            .init(name: "in", dataType: SGDataType.bool, connection: in1),
        ],
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// Or
public func logicalOr(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    guard SGDataType.bool.matches(in1) else {
        return SGValue(source: .error("Invalid logicalOr input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.bool.matches(in2) else {
        return SGValue(source: .error("Invalid logicalOr input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType).", values: [in2]))
    }
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_or",
        inputs: [
            .init(name: "in1", dataType: SGDataType.bool, connection: in1),
            .init(name: "in2", dataType: SGDataType.bool, connection: in2),
        ],
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// XOR
public func logicalXor(_ in1: SGValue, _ in2: SGValue) -> SGValue {
    guard SGDataType.bool.matches(in1) else {
        return SGValue(source: .error("Invalid logicalXor input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.bool.matches(in2) else {
        return SGValue(source: .error("Invalid logicalXor input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType).", values: [in2]))
    }
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_xor",
        inputs: [
            .init(name: "in1", dataType: SGDataType.bool, connection: in1),
            .init(name: "in2", dataType: SGDataType.bool, connection: in2),
        ],
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// Luminance
public func luminance(_ in1: SGColor, lumacoeffs: SGColor? = nil) -> SGColor {
    guard SGDataType.color3f.matches(lumacoeffs) else {
        return SGColor(source: .error("Invalid luminance input. Expected lumacoeffs data type to be SGDataType.color3f, but got \(lumacoeffs?.dataType.rawValue ?? "nil").", values: [lumacoeffs]))
    }
    if SGDataType.color3f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "lumacoeffs", dataType: SGDataType.color3f, connection: lumacoeffs),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "lumacoeffs", dataType: SGDataType.color3f, connection: lumacoeffs),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types in luminance(in1: \(in1.dataType))", values: [in1]))
}
/// Mask
public func mask(fg: SGColor? = nil, bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
    guard SGDataType.color4f.matches(fg) else {
        return SGColor(source: .error("Invalid mask input. Expected fg data type to be SGDataType.color4f, but got \(fg?.dataType.rawValue ?? "nil").", values: [fg]))
    }
    guard SGDataType.color4f.matches(bg) else {
        return SGColor(source: .error("Invalid mask input. Expected bg data type to be SGDataType.color4f, but got \(bg?.dataType.rawValue ?? "nil").", values: [bg]))
    }
    guard SGDataType.float.matches(mix) else {
        return SGColor(source: .error("Invalid mask input. Expected mix data type to be SGDataType.float, but got \(mix?.dataType.rawValue ?? "nil").", values: [mix]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_mask_color4",
        inputs: [
            .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
            .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
            .init(name: "mix", dataType: SGDataType.float, connection: mix),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Matte
public func matte(fg: SGColor? = nil, bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
    guard SGDataType.color4f.matches(fg) else {
        return SGColor(source: .error("Invalid matte input. Expected fg data type to be SGDataType.color4f, but got \(fg?.dataType.rawValue ?? "nil").", values: [fg]))
    }
    guard SGDataType.color4f.matches(bg) else {
        return SGColor(source: .error("Invalid matte input. Expected bg data type to be SGDataType.color4f, but got \(bg?.dataType.rawValue ?? "nil").", values: [bg]))
    }
    guard SGDataType.float.matches(mix) else {
        return SGColor(source: .error("Invalid matte input. Expected mix data type to be SGDataType.float, but got \(mix?.dataType.rawValue ?? "nil").", values: [mix]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_matte_color4",
        inputs: [
            .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
            .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
            .init(name: "mix", dataType: SGDataType.float, connection: mix),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Max
public func max<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.vector2h.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.vector4h.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in max(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Min
public func min<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.vector2h.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.vector4h.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4h, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in min(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Subtractive Mix
public func minus<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in minus(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Mix
public func mix<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(fg) && SGDataType.vector2h.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half2",
            inputs: [
                .init(name: "fg", dataType: SGDataType.vector2h, connection: fg),
                .init(name: "bg", dataType: SGDataType.vector2h, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(fg) && SGDataType.vector3h.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.vector3h, connection: fg),
                .init(name: "bg", dataType: SGDataType.vector3h, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(fg) && SGDataType.vector4h.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.vector4h, connection: fg),
                .init(name: "bg", dataType: SGDataType.vector4h, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(fg) && SGDataType.vector2f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector2",
            inputs: [
                .init(name: "fg", dataType: SGDataType.vector2f, connection: fg),
                .init(name: "bg", dataType: SGDataType.vector2f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(fg) && SGDataType.vector3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.vector3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.vector3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(fg) && SGDataType.vector4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.vector4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.vector4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in mix(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// In
public func mixColor(fg: SGColor? = nil, bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
    guard SGDataType.color4f.matches(fg) else {
        return SGColor(source: .error("Invalid mixColor input. Expected fg data type to be SGDataType.color4f, but got \(fg?.dataType.rawValue ?? "nil").", values: [fg]))
    }
    guard SGDataType.color4f.matches(bg) else {
        return SGColor(source: .error("Invalid mixColor input. Expected bg data type to be SGDataType.color4f, but got \(bg?.dataType.rawValue ?? "nil").", values: [bg]))
    }
    guard SGDataType.float.matches(mix) else {
        return SGColor(source: .error("Invalid mixColor input. Expected mix data type to be SGDataType.float, but got \(mix?.dataType.rawValue ?? "nil").", values: [mix]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_in_color4",
        inputs: [
            .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
            .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
            .init(name: "mix", dataType: SGDataType.float, connection: mix),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Modulo
public func modulo<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in modulo(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Multiply
public func multiply<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.matrix2d.matches(in1) && SGDataType.matrix2d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix22",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix2d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix2d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix3d.matches(in1) && SGDataType.matrix3d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix33",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix3d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix3d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix4d.matches(in1) && SGDataType.matrix4d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix44",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix4d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix4d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in multiply(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Noise 2D
public func noise2D(amplitude: SGNumeric, pivot: SGScalar? = nil, texcoord: SGVector? = nil) -> SGNumeric {
    guard SGDataType.float.matches(pivot) else {
        return SGNumeric(source: .error("Invalid noise2D input. Expected pivot data type to be SGDataType.float, but got \(pivot?.dataType.rawValue ?? "nil").", values: [pivot]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return SGNumeric(source: .error("Invalid noise2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.vector3f.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector3f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.vector4f.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector4f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_float",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector2f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector3f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector4f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGNumeric(source: .error("Unsupported input data types in noise2D(amplitude: \(amplitude.dataType))", values: [amplitude]))
}
/// Noise 3D
public func noise3D(amplitude: SGNumeric, pivot: SGScalar? = nil, position: SGVector? = nil) -> SGNumeric {
    guard SGDataType.float.matches(pivot) else {
        return SGNumeric(source: .error("Invalid noise3D input. Expected pivot data type to be SGDataType.float, but got \(pivot?.dataType.rawValue ?? "nil").", values: [pivot]))
    }
    guard SGDataType.vector3f.matches(position) else {
        return SGNumeric(source: .error("Invalid noise3D input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    if SGDataType.vector3f.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector3f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.vector4f.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector4f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_float",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector2f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector3f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.vector4f, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.float.matches(amplitude) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4FA",
            inputs: [
                .init(name: "amplitude", dataType: SGDataType.float, connection: amplitude),
                .init(name: "pivot", dataType: SGDataType.float, connection: pivot),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGNumeric(source: .error("Unsupported input data types in noise3D(amplitude: \(amplitude.dataType))", values: [amplitude]))
}
/// Normal Map
public func normalMap(_ in1: SGVector, space: SGNormalSpace = SGNormalSpace.tangent, scale: SGNumeric, normal: SGVector? = nil, tangent: SGVector? = nil) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid normalMap input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.vector3f.matches(normal) else {
        return SGVector(source: .error("Invalid normalMap input. Expected normal data type to be SGDataType.vector3f, but got \(normal?.dataType.rawValue ?? "nil").", values: [normal]))
    }
    guard SGDataType.vector3f.matches(tangent) else {
        return SGVector(source: .error("Invalid normalMap input. Expected tangent data type to be SGDataType.vector3f, but got \(tangent?.dataType.rawValue ?? "nil").", values: [tangent]))
    }
    if SGDataType.float.matches(scale) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "space", dataType: SGDataType.string, connection: SGString(source: .constant(.string(space.rawValue)))),
                .init(name: "scale", dataType: SGDataType.float, connection: scale),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "tangent", dataType: SGDataType.vector3f, connection: tangent),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector2f.matches(scale) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "space", dataType: SGDataType.string, connection: SGString(source: .constant(.string(space.rawValue)))),
                .init(name: "scale", dataType: SGDataType.vector2f, connection: scale),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "tangent", dataType: SGDataType.vector3f, connection: tangent),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGVector(source: .error("Unsupported input data types in normalMap(scale: \(scale.dataType))", values: [scale]))
}
/// Normal Map Decode
public func normalMapDecode(_ in1: SGVector) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid normalMapDecode input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_normal_map_decode",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Normalize
public func normalize(_ in1: SGVector) -> SGVector {
    if SGDataType.vector2h.matches(in1) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGVector(source: .error("Unsupported input data types in normalize(in1: \(in1.dataType))", values: [in1]))
}
/// One Minus
public func oneMinus<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in oneMinus(in1: \(in1.dataType))", values: [in1]))
}
/// Out
public func out(fg: SGColor? = nil, bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
    guard SGDataType.color4f.matches(fg) else {
        return SGColor(source: .error("Invalid out input. Expected fg data type to be SGDataType.color4f, but got \(fg?.dataType.rawValue ?? "nil").", values: [fg]))
    }
    guard SGDataType.color4f.matches(bg) else {
        return SGColor(source: .error("Invalid out input. Expected bg data type to be SGDataType.color4f, but got \(bg?.dataType.rawValue ?? "nil").", values: [bg]))
    }
    guard SGDataType.float.matches(mix) else {
        return SGColor(source: .error("Invalid out input. Expected mix data type to be SGDataType.float, but got \(mix?.dataType.rawValue ?? "nil").", values: [mix]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_out_color4",
        inputs: [
            .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
            .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
            .init(name: "mix", dataType: SGDataType.float, connection: mix),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Outside
public func outside<T>(_ in1: T, mask: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "mask", dataType: SGDataType.float, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "mask", dataType: SGDataType.float, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "mask", dataType: SGDataType.float, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(mask) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
                .init(name: "mask", dataType: SGDataType.half, connection: mask),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in outside(in1: \(in1.dataType), mask: \(mask?.dataType.rawValue ?? "nil"))", values: [in1, mask]))
}
/// Over
public func over(fg: SGColor? = nil, bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
    guard SGDataType.color4f.matches(fg) else {
        return SGColor(source: .error("Invalid over input. Expected fg data type to be SGDataType.color4f, but got \(fg?.dataType.rawValue ?? "nil").", values: [fg]))
    }
    guard SGDataType.color4f.matches(bg) else {
        return SGColor(source: .error("Invalid over input. Expected bg data type to be SGDataType.color4f, but got \(bg?.dataType.rawValue ?? "nil").", values: [bg]))
    }
    guard SGDataType.float.matches(mix) else {
        return SGColor(source: .error("Invalid over input. Expected mix data type to be SGDataType.float, but got \(mix?.dataType.rawValue ?? "nil").", values: [mix]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_over_color4",
        inputs: [
            .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
            .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
            .init(name: "mix", dataType: SGDataType.float, connection: mix),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Overlay
public func overlay<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in overlay(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Image 2D Pixel
public func pixel<T>(file: SGTexture, uWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, vWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, filter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, bias: SGScalar? = nil, dynamicMinLodClamp: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid pixel input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid pixel input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid pixel input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid pixel input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid pixel input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(bias) else {
        return T(source: .error("Invalid pixel input. Expected bias data type to be SGDataType.float, but got \(bias?.dataType.rawValue ?? "nil").", values: [bias]))
    }
    guard SGDataType.float.matches(dynamicMinLodClamp) else {
        return T(source: .error("Invalid pixel input. Expected dynamicMinLodClamp data type to be SGDataType.float, but got \(dynamicMinLodClamp?.dataType.rawValue ?? "nil").", values: [dynamicMinLodClamp]))
    }
    guard SGDataType.vector2i.matches(offset) else {
        return T(source: .error("Invalid pixel input. Expected offset data type to be SGDataType.vector2i, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixel_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in pixel(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Image 2D Gradient Pixel
public func pixelGradient<T>(file: SGTexture, uWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, vWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, filter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, dynamicMinLodClamp: SGScalar? = nil, gradientDpdx: SGVector? = nil, gradientDpdy: SGVector? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid pixelGradient input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid pixelGradient input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid pixelGradient input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid pixelGradient input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid pixelGradient input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(dynamicMinLodClamp) else {
        return T(source: .error("Invalid pixelGradient input. Expected dynamicMinLodClamp data type to be SGDataType.float, but got \(dynamicMinLodClamp?.dataType.rawValue ?? "nil").", values: [dynamicMinLodClamp]))
    }
    guard SGDataType.vector2f.matches(gradientDpdx) else {
        return T(source: .error("Invalid pixelGradient input. Expected gradientDpdx data type to be SGDataType.vector2f, but got \(gradientDpdx?.dataType.rawValue ?? "nil").", values: [gradientDpdx]))
    }
    guard SGDataType.vector2f.matches(gradientDpdy) else {
        return T(source: .error("Invalid pixelGradient input. Expected gradientDpdy data type to be SGDataType.vector2f, but got \(gradientDpdy?.dataType.rawValue ?? "nil").", values: [gradientDpdy]))
    }
    guard SGDataType.vector2i.matches(offset) else {
        return T(source: .error("Invalid pixelGradient input. Expected offset data type to be SGDataType.vector2i, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradient_dPdx", dataType: SGDataType.vector2f, connection: gradientDpdx),
                .init(name: "gradient_dPdy", dataType: SGDataType.vector2f, connection: gradientDpdy),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradient_dPdx", dataType: SGDataType.vector2f, connection: gradientDpdx),
                .init(name: "gradient_dPdy", dataType: SGDataType.vector2f, connection: gradientDpdy),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelGradient_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradient_dPdx", dataType: SGDataType.vector2f, connection: gradientDpdx),
                .init(name: "gradient_dPdy", dataType: SGDataType.vector2f, connection: gradientDpdy),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in pixelGradient(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Image 2D LOD Pixel
public func pixelLOD<T>(file: SGTexture, uWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, vWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, filter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, lod: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid pixelLOD input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid pixelLOD input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid pixelLOD input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid pixelLOD input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid pixelLOD input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(lod) else {
        return T(source: .error("Invalid pixelLOD input. Expected lod data type to be SGDataType.float, but got \(lod?.dataType.rawValue ?? "nil").", values: [lod]))
    }
    guard SGDataType.vector2i.matches(offset) else {
        return T(source: .error("Invalid pixelLOD input. Expected offset data type to be SGDataType.vector2i, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DPixelLOD_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in pixelLOD(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Place 2D
public func place2D(texcoord: SGVector? = nil, pivot: SGVector? = nil, scale: SGVector? = nil, rotate: SGScalar? = nil, offset: SGVector? = nil) -> SGVector {
    guard SGDataType.vector2f.matches(texcoord) else {
        return SGVector(source: .error("Invalid place2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.vector2f.matches(pivot) else {
        return SGVector(source: .error("Invalid place2D input. Expected pivot data type to be SGDataType.vector2f, but got \(pivot?.dataType.rawValue ?? "nil").", values: [pivot]))
    }
    guard SGDataType.vector2f.matches(scale) else {
        return SGVector(source: .error("Invalid place2D input. Expected scale data type to be SGDataType.vector2f, but got \(scale?.dataType.rawValue ?? "nil").", values: [scale]))
    }
    guard SGDataType.float.matches(rotate) else {
        return SGVector(source: .error("Invalid place2D input. Expected rotate data type to be SGDataType.float, but got \(rotate?.dataType.rawValue ?? "nil").", values: [rotate]))
    }
    guard SGDataType.vector2f.matches(offset) else {
        return SGVector(source: .error("Invalid place2D input. Expected offset data type to be SGDataType.vector2f, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_place2d_vector2",
        inputs: [
            .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            .init(name: "pivot", dataType: SGDataType.vector2f, connection: pivot),
            .init(name: "scale", dataType: SGDataType.vector2f, connection: scale),
            .init(name: "rotate", dataType: SGDataType.float, connection: rotate),
            .init(name: "offset", dataType: SGDataType.vector2f, connection: offset),
        ],
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Additive Mix
public func plus<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in plus(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Power
public func pow<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in pow(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Premultiply
public func premult(_ in1: SGColor) -> SGColor {
    guard SGDataType.color4f.matches(in1) else {
        return SGColor(source: .error("Invalid premult input. Expected in1 data type to be SGDataType.color4f, but got \(in1.dataType).", values: [in1]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_premult_color4",
        inputs: [
            .init(name: "in", dataType: SGDataType.color4f, connection: in1),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Ramp 4 Corners
public func ramp4<T>(valuetl: T, valuetr: T, valuebl: T, valuebr: T, texcoord: SGVector? = nil) -> T where T: SGNumeric {
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid ramp4 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.color3f.matches(valuetl) && SGDataType.color3f.matches(valuetr) && SGDataType.color3f.matches(valuebl) && SGDataType.color3f.matches(valuebr) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color3",
            inputs: [
                .init(name: "valuetl", dataType: SGDataType.color3f, connection: valuetl),
                .init(name: "valuetr", dataType: SGDataType.color3f, connection: valuetr),
                .init(name: "valuebl", dataType: SGDataType.color3f, connection: valuebl),
                .init(name: "valuebr", dataType: SGDataType.color3f, connection: valuebr),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(valuetl) && SGDataType.color4f.matches(valuetr) && SGDataType.color4f.matches(valuebl) && SGDataType.color4f.matches(valuebr) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color4",
            inputs: [
                .init(name: "valuetl", dataType: SGDataType.color4f, connection: valuetl),
                .init(name: "valuetr", dataType: SGDataType.color4f, connection: valuetr),
                .init(name: "valuebl", dataType: SGDataType.color4f, connection: valuebl),
                .init(name: "valuebr", dataType: SGDataType.color4f, connection: valuebr),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(valuetl) && SGDataType.float.matches(valuetr) && SGDataType.float.matches(valuebl) && SGDataType.float.matches(valuebr) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_float",
            inputs: [
                .init(name: "valuetl", dataType: SGDataType.float, connection: valuetl),
                .init(name: "valuetr", dataType: SGDataType.float, connection: valuetr),
                .init(name: "valuebl", dataType: SGDataType.float, connection: valuebl),
                .init(name: "valuebr", dataType: SGDataType.float, connection: valuebr),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(valuetl) && SGDataType.vector2f.matches(valuetr) && SGDataType.vector2f.matches(valuebl) && SGDataType.vector2f.matches(valuebr) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector2",
            inputs: [
                .init(name: "valuetl", dataType: SGDataType.vector2f, connection: valuetl),
                .init(name: "valuetr", dataType: SGDataType.vector2f, connection: valuetr),
                .init(name: "valuebl", dataType: SGDataType.vector2f, connection: valuebl),
                .init(name: "valuebr", dataType: SGDataType.vector2f, connection: valuebr),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(valuetl) && SGDataType.vector3f.matches(valuetr) && SGDataType.vector3f.matches(valuebl) && SGDataType.vector3f.matches(valuebr) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector3",
            inputs: [
                .init(name: "valuetl", dataType: SGDataType.vector3f, connection: valuetl),
                .init(name: "valuetr", dataType: SGDataType.vector3f, connection: valuetr),
                .init(name: "valuebl", dataType: SGDataType.vector3f, connection: valuebl),
                .init(name: "valuebr", dataType: SGDataType.vector3f, connection: valuebr),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(valuetl) && SGDataType.vector4f.matches(valuetr) && SGDataType.vector4f.matches(valuebl) && SGDataType.vector4f.matches(valuebr) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector4",
            inputs: [
                .init(name: "valuetl", dataType: SGDataType.vector4f, connection: valuetl),
                .init(name: "valuetr", dataType: SGDataType.vector4f, connection: valuetr),
                .init(name: "valuebl", dataType: SGDataType.vector4f, connection: valuebl),
                .init(name: "valuebr", dataType: SGDataType.vector4f, connection: valuebr),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ramp4(valuetl: \(valuetl.dataType), valuetr: \(valuetr.dataType), valuebl: \(valuebl.dataType), valuebr: \(valuebr.dataType))", values: [valuetl, valuetr, valuebl, valuebr]))
}
/// Ramp Horizontal
public func ramplr<T>(valuel: T, valuer: T, texcoord: SGVector? = nil) -> T where T: SGNumeric {
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid ramplr input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.color3f.matches(valuel) && SGDataType.color3f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color3",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.color3f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.color3f, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(valuel) && SGDataType.color4f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color4",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.color4f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.color4f, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(valuel) && SGDataType.float.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_float",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.float, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.float, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(valuel) && SGDataType.half.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.half, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.half, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(valuel) && SGDataType.vector2h.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half2",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector2h, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector2h, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(valuel) && SGDataType.vector3h.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half3",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector3h, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector3h, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(valuel) && SGDataType.vector4h.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half4",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector4h, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector4h, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(valuel) && SGDataType.vector2f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector2",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector2f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector2f, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(valuel) && SGDataType.vector3f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector3",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector3f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector3f, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(valuel) && SGDataType.vector4f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector4",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector4f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector4f, connection: valuer),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ramplr(valuel: \(valuel.dataType), valuer: \(valuer.dataType))", values: [valuel, valuer]))
}
/// Ramp Vertical
public func ramptb<T>(valuet: T, valueb: T, texcoord: SGVector? = nil) -> T where T: SGNumeric {
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid ramptb input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.color3f.matches(valuet) && SGDataType.color3f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color3",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.color3f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.color3f, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(valuet) && SGDataType.color4f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color4",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.color4f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.color4f, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(valuet) && SGDataType.float.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_float",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.float, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.float, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(valuet) && SGDataType.half.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.half, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.half, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(valuet) && SGDataType.vector2h.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half2",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector2h, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector2h, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(valuet) && SGDataType.vector3h.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half3",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector3h, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector3h, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(valuet) && SGDataType.vector4h.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half4",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector4h, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector4h, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(valuet) && SGDataType.vector2f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector2",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector2f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector2f, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(valuet) && SGDataType.vector3f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector3",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector3f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector3f, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(valuet) && SGDataType.vector4f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector4",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector4f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector4f, connection: valueb),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in ramptb(valuet: \(valuet.dataType), valueb: \(valueb.dataType))", values: [valuet, valueb]))
}
/// Range
public func range<T>(_ in1: T, inlow: SGNumeric, inhigh: SGNumeric, gamma: SGNumeric, outlow: SGNumeric, outhigh: SGNumeric, doclamp: SGValue? = nil) -> T where T: SGNumeric {
    guard SGDataType.bool.matches(doclamp) else {
        return T(source: .error("Invalid range input. Expected doclamp data type to be SGDataType.bool, but got \(doclamp?.dataType.rawValue ?? "nil").", values: [doclamp]))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(inlow) && SGDataType.color3f.matches(inhigh) && SGDataType.color3f.matches(gamma) && SGDataType.color3f.matches(outlow) && SGDataType.color3f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.color3f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.color3f, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.color3f, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.color3f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.color3f, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(gamma) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.float, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(inlow) && SGDataType.color4f.matches(inhigh) && SGDataType.color4f.matches(gamma) && SGDataType.color4f.matches(outlow) && SGDataType.color4f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.color4f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.color4f, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.color4f, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.color4f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.color4f, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(gamma) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.float, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(gamma) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.float, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(inlow) && SGDataType.vector2f.matches(inhigh) && SGDataType.vector2f.matches(gamma) && SGDataType.vector2f.matches(outlow) && SGDataType.vector2f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector2f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector2f, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.vector2f, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.vector2f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector2f, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(gamma) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.float, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(inlow) && SGDataType.vector3f.matches(inhigh) && SGDataType.vector3f.matches(gamma) && SGDataType.vector3f.matches(outlow) && SGDataType.vector3f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector3f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector3f, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.vector3f, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.vector3f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector3f, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(gamma) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.float, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(inlow) && SGDataType.vector4f.matches(inhigh) && SGDataType.vector4f.matches(gamma) && SGDataType.vector4f.matches(outlow) && SGDataType.vector4f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector4f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector4f, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.vector4f, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.vector4f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector4f, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(gamma) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "gamma", dataType: SGDataType.float, connection: gamma),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
                .init(name: "doclamp", dataType: SGDataType.bool, connection: doclamp),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in range(in1: \(in1.dataType), inlow: \(inlow.dataType), inhigh: \(inhigh.dataType), gamma: \(gamma.dataType), outlow: \(outlow.dataType), outhigh: \(outhigh.dataType))", values: [in1, inlow, inhigh, gamma, outlow, outhigh]))
}
/// Image 2D Read
public func read<T>(file: SGTexture, defaultValue: T, x: SGScalar? = nil, y: SGScalar? = nil, lod: SGScalar? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid read input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(x) else {
        return T(source: .error("Invalid read input. Expected x data type to be SGDataType.int, but got \(x?.dataType.rawValue ?? "nil").", values: [x]))
    }
    guard SGDataType.int.matches(y) else {
        return T(source: .error("Invalid read input. Expected y data type to be SGDataType.int, but got \(y?.dataType.rawValue ?? "nil").", values: [y]))
    }
    guard SGDataType.int.matches(lod) else {
        return T(source: .error("Invalid read input. Expected lod data type to be SGDataType.int, but got \(lod?.dataType.rawValue ?? "nil").", values: [lod]))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureRead_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "x", dataType: SGDataType.int, connection: x),
                .init(name: "y", dataType: SGDataType.int, connection: y),
                .init(name: "lod", dataType: SGDataType.int, connection: lod),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureRead_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "x", dataType: SGDataType.int, connection: x),
                .init(name: "y", dataType: SGDataType.int, connection: y),
                .init(name: "lod", dataType: SGDataType.int, connection: lod),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in read(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Reflect
public func reflect(_ in1: SGVector, normal: SGVector? = nil) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid reflect input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.vector3f.matches(normal) else {
        return SGVector(source: .error("Invalid reflect input. Expected normal data type to be SGDataType.vector3f, but got \(normal?.dataType.rawValue ?? "nil").", values: [normal]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_reflect_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Refract
public func refract(_ in1: SGVector, normal: SGVector? = nil, eta: SGScalar? = nil) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid refract input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.vector3f.matches(normal) else {
        return SGVector(source: .error("Invalid refract input. Expected normal data type to be SGDataType.vector3f, but got \(normal?.dataType.rawValue ?? "nil").", values: [normal]))
    }
    guard SGDataType.float.matches(eta) else {
        return SGVector(source: .error("Invalid refract input. Expected eta data type to be SGDataType.float, but got \(eta?.dataType.rawValue ?? "nil").", values: [eta]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_refract_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
            .init(name: "eta", dataType: SGDataType.float, connection: eta),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Remap
public func remap<T>(_ in1: T, inlow: SGNumeric, inhigh: SGNumeric, outlow: SGNumeric, outhigh: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(inlow) && SGDataType.color3f.matches(inhigh) && SGDataType.color3f.matches(outlow) && SGDataType.color3f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.color3f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.color3f, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.color3f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.color3f, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(inlow) && SGDataType.color4f.matches(inhigh) && SGDataType.color4f.matches(outlow) && SGDataType.color4f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.color4f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.color4f, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.color4f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.color4f, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(inlow) && SGDataType.half.matches(inhigh) && SGDataType.half.matches(outlow) && SGDataType.half.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
                .init(name: "inlow", dataType: SGDataType.half, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.half, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.half, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.half, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.vector2h.matches(inlow) && SGDataType.vector2h.matches(inhigh) && SGDataType.vector2h.matches(outlow) && SGDataType.vector2h.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector2h, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector2h, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.vector2h, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector2h, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(inlow) && SGDataType.vector3h.matches(inhigh) && SGDataType.vector3h.matches(outlow) && SGDataType.vector3h.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector3h, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector3h, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.vector3h, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector3h, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.vector4h.matches(inlow) && SGDataType.vector4h.matches(inhigh) && SGDataType.vector4h.matches(outlow) && SGDataType.vector4h.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector4h, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector4h, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.vector4h, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector4h, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(inlow) && SGDataType.vector2f.matches(inhigh) && SGDataType.vector2f.matches(outlow) && SGDataType.vector2f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector2f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector2f, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.vector2f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector2f, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(inlow) && SGDataType.vector3f.matches(inhigh) && SGDataType.vector3f.matches(outlow) && SGDataType.vector3f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector3f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector3f, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.vector3f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector3f, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(inlow) && SGDataType.vector4f.matches(inhigh) && SGDataType.vector4f.matches(outlow) && SGDataType.vector4f.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.vector4f, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.vector4f, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.vector4f, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.vector4f, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(inlow) && SGDataType.float.matches(inhigh) && SGDataType.float.matches(outlow) && SGDataType.float.matches(outhigh) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "inlow", dataType: SGDataType.float, connection: inlow),
                .init(name: "inhigh", dataType: SGDataType.float, connection: inhigh),
                .init(name: "outlow", dataType: SGDataType.float, connection: outlow),
                .init(name: "outhigh", dataType: SGDataType.float, connection: outhigh),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in remap(in1: \(in1.dataType), inlow: \(inlow.dataType), inhigh: \(inhigh.dataType), outlow: \(outlow.dataType), outhigh: \(outhigh.dataType))", values: [in1, inlow, inhigh, outlow, outhigh]))
}
/// RGB to HSV
public func rgbToHSV(_ in1: SGColor) -> SGColor {
    if SGDataType.color3f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types in rgbToHSV(in1: \(in1.dataType))", values: [in1]))
}
/// Rotate 2D
public func rotate2D(_ in1: SGVector, amount: SGScalar? = nil) -> SGVector {
    guard SGDataType.vector2f.matches(in1) else {
        return SGVector(source: .error("Invalid rotate2D input. Expected in1 data type to be SGDataType.vector2f, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.float.matches(amount) else {
        return SGVector(source: .error("Invalid rotate2D input. Expected amount data type to be SGDataType.float, but got \(amount?.dataType.rawValue ?? "nil").", values: [amount]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_rotate2d_vector2",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            .init(name: "amount", dataType: SGDataType.float, connection: amount),
        ],
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Rotate 3D
public func rotate3D(_ in1: SGVector, amount: SGScalar? = nil, axis: SGVector? = nil) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid rotate3D input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    guard SGDataType.float.matches(amount) else {
        return SGVector(source: .error("Invalid rotate3D input. Expected amount data type to be SGDataType.float, but got \(amount?.dataType.rawValue ?? "nil").", values: [amount]))
    }
    guard SGDataType.vector3f.matches(axis) else {
        return SGVector(source: .error("Invalid rotate3D input. Expected axis data type to be SGDataType.vector3f, but got \(axis?.dataType.rawValue ?? "nil").", values: [axis]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_rotate3d_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            .init(name: "amount", dataType: SGDataType.float, connection: amount),
            .init(name: "axis", dataType: SGDataType.vector3f, connection: axis),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Round
public func round<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in round(in1: \(in1.dataType))", values: [in1]))
}
/// Safe Power
public func safePow<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in safePow(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Image 2D
public func sample<T>(file: SGTexture, uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, bias: SGScalar? = nil, dynamicMinLodClamp: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid sample input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid sample input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid sample input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid sample input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid sample input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(bias) else {
        return T(source: .error("Invalid sample input. Expected bias data type to be SGDataType.float, but got \(bias?.dataType.rawValue ?? "nil").", values: [bias]))
    }
    guard SGDataType.float.matches(dynamicMinLodClamp) else {
        return T(source: .error("Invalid sample input. Expected dynamicMinLodClamp data type to be SGDataType.float, but got \(dynamicMinLodClamp?.dataType.rawValue ?? "nil").", values: [dynamicMinLodClamp]))
    }
    guard SGDataType.vector2i.matches(offset) else {
        return T(source: .error("Invalid sample input. Expected offset data type to be SGDataType.vector2i, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2D_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sample(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Cube Image
public func sampleCube<T>(file: SGTexture, uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, bias: SGScalar? = nil, dynamicMinLodClamp: SGScalar? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid sampleCube input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid sampleCube input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid sampleCube input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid sampleCube input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector3f.matches(texcoord) else {
        return T(source: .error("Invalid sampleCube input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(bias) else {
        return T(source: .error("Invalid sampleCube input. Expected bias data type to be SGDataType.float, but got \(bias?.dataType.rawValue ?? "nil").", values: [bias]))
    }
    guard SGDataType.float.matches(dynamicMinLodClamp) else {
        return T(source: .error("Invalid sampleCube input. Expected dynamicMinLodClamp data type to be SGDataType.float, but got \(dynamicMinLodClamp?.dataType.rawValue ?? "nil").", values: [dynamicMinLodClamp]))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCube_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector3f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCube_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector3f, connection: texcoord),
                .init(name: "bias", dataType: SGDataType.float, connection: bias),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sampleCube(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Cube Image Gradient
public func sampleCubeGradient<T>(file: SGTexture, uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, dynamicMinLodClamp: SGScalar? = nil, gradientcubeDpdx: SGVector? = nil, gradientcubeDpdy: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector3f.matches(texcoord) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(dynamicMinLodClamp) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected dynamicMinLodClamp data type to be SGDataType.float, but got \(dynamicMinLodClamp?.dataType.rawValue ?? "nil").", values: [dynamicMinLodClamp]))
    }
    guard SGDataType.vector3f.matches(gradientcubeDpdx) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected gradientcubeDpdx data type to be SGDataType.vector3f, but got \(gradientcubeDpdx?.dataType.rawValue ?? "nil").", values: [gradientcubeDpdx]))
    }
    guard SGDataType.vector3f.matches(gradientcubeDpdy) else {
        return T(source: .error("Invalid sampleCubeGradient input. Expected gradientcubeDpdy data type to be SGDataType.vector3f, but got \(gradientcubeDpdy?.dataType.rawValue ?? "nil").", values: [gradientcubeDpdy]))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeGradient_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector3f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradientcube_dPdx", dataType: SGDataType.vector3f, connection: gradientcubeDpdx),
                .init(name: "gradientcube_dPdy", dataType: SGDataType.vector3f, connection: gradientcubeDpdy),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeGradient_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector3f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradientcube_dPdx", dataType: SGDataType.vector3f, connection: gradientcubeDpdx),
                .init(name: "gradientcube_dPdy", dataType: SGDataType.vector3f, connection: gradientcubeDpdy),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sampleCubeGradient(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Cube Image LOD
public func sampleCubeLOD<T>(file: SGTexture, uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, lod: SGScalar? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid sampleCubeLOD input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid sampleCubeLOD input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid sampleCubeLOD input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid sampleCubeLOD input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector3f.matches(texcoord) else {
        return T(source: .error("Invalid sampleCubeLOD input. Expected texcoord data type to be SGDataType.vector3f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(lod) else {
        return T(source: .error("Invalid sampleCubeLOD input. Expected lod data type to be SGDataType.float, but got \(lod?.dataType.rawValue ?? "nil").", values: [lod]))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeLOD_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector3f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTextureCubeLOD_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector3f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sampleCubeLOD(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Image 2D Gradient
public func sampleGradient<T>(file: SGTexture, uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, dynamicMinLodClamp: SGScalar? = nil, gradientDpdx: SGVector? = nil, gradientDpdy: SGVector? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid sampleGradient input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid sampleGradient input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid sampleGradient input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid sampleGradient input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid sampleGradient input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(dynamicMinLodClamp) else {
        return T(source: .error("Invalid sampleGradient input. Expected dynamicMinLodClamp data type to be SGDataType.float, but got \(dynamicMinLodClamp?.dataType.rawValue ?? "nil").", values: [dynamicMinLodClamp]))
    }
    guard SGDataType.vector2f.matches(gradientDpdx) else {
        return T(source: .error("Invalid sampleGradient input. Expected gradientDpdx data type to be SGDataType.vector2f, but got \(gradientDpdx?.dataType.rawValue ?? "nil").", values: [gradientDpdx]))
    }
    guard SGDataType.vector2f.matches(gradientDpdy) else {
        return T(source: .error("Invalid sampleGradient input. Expected gradientDpdy data type to be SGDataType.vector2f, but got \(gradientDpdy?.dataType.rawValue ?? "nil").", values: [gradientDpdy]))
    }
    guard SGDataType.vector2i.matches(offset) else {
        return T(source: .error("Invalid sampleGradient input. Expected offset data type to be SGDataType.vector2i, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradient_dPdx", dataType: SGDataType.vector2f, connection: gradientDpdx),
                .init(name: "gradient_dPdy", dataType: SGDataType.vector2f, connection: gradientDpdy),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradient_dPdx", dataType: SGDataType.vector2f, connection: gradientDpdx),
                .init(name: "gradient_dPdy", dataType: SGDataType.vector2f, connection: gradientDpdy),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DGradient_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "dynamic_min_lod_clamp", dataType: SGDataType.float, connection: dynamicMinLodClamp),
                .init(name: "gradient_dPdx", dataType: SGDataType.vector2f, connection: gradientDpdx),
                .init(name: "gradient_dPdy", dataType: SGDataType.vector2f, connection: gradientDpdy),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sampleGradient(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Image 2D LOD
public func sampleLOD<T>(file: SGTexture, uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, lod: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid sampleLOD input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.int.matches(maxAnisotropy) else {
        return T(source: .error("Invalid sampleLOD input. Expected maxAnisotropy data type to be SGDataType.int, but got \(maxAnisotropy?.dataType.rawValue ?? "nil").", values: [maxAnisotropy]))
    }
    guard SGDataType.float.matches(maxLodClamp) else {
        return T(source: .error("Invalid sampleLOD input. Expected maxLodClamp data type to be SGDataType.float, but got \(maxLodClamp?.dataType.rawValue ?? "nil").", values: [maxLodClamp]))
    }
    guard SGDataType.float.matches(minLodClamp) else {
        return T(source: .error("Invalid sampleLOD input. Expected minLodClamp data type to be SGDataType.float, but got \(minLodClamp?.dataType.rawValue ?? "nil").", values: [minLodClamp]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid sampleLOD input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(lod) else {
        return T(source: .error("Invalid sampleLOD input. Expected lod data type to be SGDataType.float, but got \(lod?.dataType.rawValue ?? "nil").", values: [lod]))
    }
    guard SGDataType.vector2i.matches(offset) else {
        return T(source: .error("Invalid sampleLOD input. Expected offset data type to be SGDataType.vector2i, but got \(offset?.dataType.rawValue ?? "nil").", values: [offset]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_RealityKitTexture2DLOD_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "u_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(uWrapMode.rawValue)))),
                .init(name: "v_wrap_mode", dataType: SGDataType.string, connection: SGString(source: .constant(.string(vWrapMode.rawValue)))),
                .init(name: "border_color", dataType: SGDataType.string, connection: SGString(source: .constant(.string(borderColor.rawValue)))),
                .init(name: "mag_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(magFilter.rawValue)))),
                .init(name: "min_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(minFilter.rawValue)))),
                .init(name: "mip_filter", dataType: SGDataType.string, connection: SGString(source: .constant(.string(mipFilter.rawValue)))),
                .init(name: "max_anisotropy", dataType: SGDataType.int, connection: maxAnisotropy),
                .init(name: "max_lod_clamp", dataType: SGDataType.float, connection: maxLodClamp),
                .init(name: "min_lod_clamp", dataType: SGDataType.float, connection: minLodClamp),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "lod", dataType: SGDataType.float, connection: lod),
                .init(name: "offset", dataType: SGDataType.vector2i, connection: offset),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sampleLOD(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Saturate
public func saturate(_ in1: SGColor, amount: SGScalar? = nil, lumacoeffs: SGColor? = nil) -> SGColor {
    guard SGDataType.float.matches(amount) else {
        return SGColor(source: .error("Invalid saturate input. Expected amount data type to be SGDataType.float, but got \(amount?.dataType.rawValue ?? "nil").", values: [amount]))
    }
    guard SGDataType.color3f.matches(lumacoeffs) else {
        return SGColor(source: .error("Invalid saturate input. Expected lumacoeffs data type to be SGDataType.color3f, but got \(lumacoeffs?.dataType.rawValue ?? "nil").", values: [lumacoeffs]))
    }
    if SGDataType.color3f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "lumacoeffs", dataType: SGDataType.color3f, connection: lumacoeffs),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "amount", dataType: SGDataType.float, connection: amount),
                .init(name: "lumacoeffs", dataType: SGDataType.color3f, connection: lumacoeffs),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types in saturate(in1: \(in1.dataType))", values: [in1]))
}
/// Screen
public func screen<T>(fg: T, bg: T, mix: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(fg) && SGDataType.color3f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color3",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color3f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color3f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(fg) && SGDataType.color4f.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color4",
            inputs: [
                .init(name: "fg", dataType: SGDataType.color4f, connection: fg),
                .init(name: "bg", dataType: SGDataType.color4f, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(fg) && SGDataType.float.matches(bg) && SGDataType.float.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_float",
            inputs: [
                .init(name: "fg", dataType: SGDataType.float, connection: fg),
                .init(name: "bg", dataType: SGDataType.float, connection: bg),
                .init(name: "mix", dataType: SGDataType.float, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(fg) && SGDataType.half.matches(bg) && SGDataType.half.matches(mix) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_half",
            inputs: [
                .init(name: "fg", dataType: SGDataType.half, connection: fg),
                .init(name: "bg", dataType: SGDataType.half, connection: bg),
                .init(name: "mix", dataType: SGDataType.half, connection: mix),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types in screen(fg: \(fg.dataType), bg: \(bg.dataType), mix: \(mix?.dataType.rawValue ?? "nil"))", values: [fg, bg, mix]))
}
/// Sign
public func sign<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sign(in1: \(in1.dataType))", values: [in1]))
}
/// Sin
public func sin<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sin(in1: \(in1.dataType))", values: [in1]))
}
/// Smooth Step
public func smoothStep<T>(_ in1: T, low: SGNumeric, high: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(low) && SGDataType.color3f.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "low", dataType: SGDataType.color3f, connection: low),
                .init(name: "high", dataType: SGDataType.color3f, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(low) && SGDataType.color4f.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "low", dataType: SGDataType.color4f, connection: low),
                .init(name: "high", dataType: SGDataType.color4f, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(low) && SGDataType.half.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
                .init(name: "low", dataType: SGDataType.half, connection: low),
                .init(name: "high", dataType: SGDataType.half, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.vector2h.matches(low) && SGDataType.vector2h.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "low", dataType: SGDataType.vector2h, connection: low),
                .init(name: "high", dataType: SGDataType.vector2h, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector2h.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.vector3h.matches(low) && SGDataType.vector3h.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "low", dataType: SGDataType.vector3h, connection: low),
                .init(name: "high", dataType: SGDataType.vector3h, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector3h.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.vector4h.matches(low) && SGDataType.vector4h.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "low", dataType: SGDataType.vector4h, connection: low),
                .init(name: "high", dataType: SGDataType.vector4h, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector4h.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(low) && SGDataType.vector2f.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "low", dataType: SGDataType.vector2f, connection: low),
                .init(name: "high", dataType: SGDataType.vector2f, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(low) && SGDataType.vector3f.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "low", dataType: SGDataType.vector3f, connection: low),
                .init(name: "high", dataType: SGDataType.vector3f, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(low) && SGDataType.vector4f.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "low", dataType: SGDataType.vector4f, connection: low),
                .init(name: "high", dataType: SGDataType.vector4f, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(low) && SGDataType.float.matches(high) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4FA",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "low", dataType: SGDataType.float, connection: low),
                .init(name: "high", dataType: SGDataType.float, connection: high),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in smoothStep(in1: \(in1.dataType), low: \(low.dataType), high: \(high.dataType))", values: [in1, low, high]))
}
/// Split Horizontal
public func splitlr<T>(valuel: T, valuer: T, center: SGScalar? = nil, texcoord: SGVector? = nil) -> T where T: SGNumeric {
    guard SGDataType.float.matches(center) else {
        return T(source: .error("Invalid splitlr input. Expected center data type to be SGDataType.float, but got \(center?.dataType.rawValue ?? "nil").", values: [center]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid splitlr input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.color3f.matches(valuel) && SGDataType.color3f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color3",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.color3f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.color3f, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(valuel) && SGDataType.color4f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color4",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.color4f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.color4f, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(valuel) && SGDataType.float.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_float",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.float, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.float, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(valuel) && SGDataType.half.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_half",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.half, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.half, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(valuel) && SGDataType.vector2f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector2",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector2f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector2f, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(valuel) && SGDataType.vector3f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector3",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector3f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector3f, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(valuel) && SGDataType.vector4f.matches(valuer) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector4",
            inputs: [
                .init(name: "valuel", dataType: SGDataType.vector4f, connection: valuel),
                .init(name: "valuer", dataType: SGDataType.vector4f, connection: valuer),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in splitlr(valuel: \(valuel.dataType), valuer: \(valuer.dataType))", values: [valuel, valuer]))
}
/// Split Vertical
public func splittb<T>(valuet: T, valueb: T, center: SGScalar? = nil, texcoord: SGVector? = nil) -> T where T: SGNumeric {
    guard SGDataType.float.matches(center) else {
        return T(source: .error("Invalid splittb input. Expected center data type to be SGDataType.float, but got \(center?.dataType.rawValue ?? "nil").", values: [center]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid splittb input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    if SGDataType.color3f.matches(valuet) && SGDataType.color3f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color3",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.color3f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.color3f, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(valuet) && SGDataType.color4f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color4",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.color4f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.color4f, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(valuet) && SGDataType.float.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_float",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.float, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.float, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(valuet) && SGDataType.half.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.half, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.half, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(valuet) && SGDataType.vector2h.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half2",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector2h, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector2h, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(valuet) && SGDataType.vector3h.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half3",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector3h, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector3h, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(valuet) && SGDataType.vector4h.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half4",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector4h, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector4h, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(valuet) && SGDataType.vector2f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector2",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector2f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector2f, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(valuet) && SGDataType.vector3f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector3",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector3f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector3f, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(valuet) && SGDataType.vector4f.matches(valueb) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector4",
            inputs: [
                .init(name: "valuet", dataType: SGDataType.vector4f, connection: valuet),
                .init(name: "valueb", dataType: SGDataType.vector4f, connection: valueb),
                .init(name: "center", dataType: SGDataType.float, connection: center),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in splittb(valuet: \(valuet.dataType), valueb: \(valueb.dataType))", values: [valuet, valueb]))
}
/// Square Root
public func sqrt<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in sqrt(in1: \(in1.dataType))", values: [in1]))
}
/// Step
public func step<T>(_ in1: T, edge: T) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(edge) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color3",
            inputs: [
                .init(name: "in", dataType: SGDataType.color3f, connection: in1),
                .init(name: "edge", dataType: SGDataType.color3f, connection: edge),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(edge) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color4",
            inputs: [
                .init(name: "in", dataType: SGDataType.color4f, connection: in1),
                .init(name: "edge", dataType: SGDataType.color4f, connection: edge),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(edge) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
                .init(name: "edge", dataType: SGDataType.float, connection: edge),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(edge) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "edge", dataType: SGDataType.vector2f, connection: edge),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(edge) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "edge", dataType: SGDataType.vector3f, connection: edge),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(edge) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "edge", dataType: SGDataType.vector4f, connection: edge),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in step(in1: \(in1.dataType), edge: \(edge.dataType))", values: [in1, edge]))
}
/// Subtract
public func subtract<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.matrix2d.matches(in1) && SGDataType.matrix2d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix2d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix2d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix2d.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix2d, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix3d.matches(in1) && SGDataType.matrix3d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix3d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix3d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix3d.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix3d, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix4d.matches(in1) && SGDataType.matrix4d.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix4d, connection: in1),
                .init(name: "in2", dataType: SGDataType.matrix4d, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if SGDataType.matrix4d.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.matrix4d, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.float.matches(in2) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4FA",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in subtract(in1: \(in1.dataType), in2: \(in2.dataType))", values: [in1, in2]))
}
/// Switch
public func switchValue<T>(_ in1: T, _ in2: T, _ in3: T, _ in4: T, _ in5: T, _ in6: T, _ in7: T, _ in8: T, _ in9: T, _ in10: T, which: SGScalar? = nil) -> T where T: SGNumeric {
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) && SGDataType.color3f.matches(in3) && SGDataType.color3f.matches(in4) && SGDataType.color3f.matches(in5) && SGDataType.color3f.matches(in6) && SGDataType.color3f.matches(in7) && SGDataType.color3f.matches(in8) && SGDataType.color3f.matches(in9) && SGDataType.color3f.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
                .init(name: "in3", dataType: SGDataType.color3f, connection: in3),
                .init(name: "in4", dataType: SGDataType.color3f, connection: in4),
                .init(name: "in5", dataType: SGDataType.color3f, connection: in5),
                .init(name: "in6", dataType: SGDataType.color3f, connection: in6),
                .init(name: "in7", dataType: SGDataType.color3f, connection: in7),
                .init(name: "in8", dataType: SGDataType.color3f, connection: in8),
                .init(name: "in9", dataType: SGDataType.color3f, connection: in9),
                .init(name: "in10", dataType: SGDataType.color3f, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color3f.matches(in1) && SGDataType.color3f.matches(in2) && SGDataType.color3f.matches(in3) && SGDataType.color3f.matches(in4) && SGDataType.color3f.matches(in5) && SGDataType.color3f.matches(in6) && SGDataType.color3f.matches(in7) && SGDataType.color3f.matches(in8) && SGDataType.color3f.matches(in9) && SGDataType.color3f.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3I",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color3f, connection: in2),
                .init(name: "in3", dataType: SGDataType.color3f, connection: in3),
                .init(name: "in4", dataType: SGDataType.color3f, connection: in4),
                .init(name: "in5", dataType: SGDataType.color3f, connection: in5),
                .init(name: "in6", dataType: SGDataType.color3f, connection: in6),
                .init(name: "in7", dataType: SGDataType.color3f, connection: in7),
                .init(name: "in8", dataType: SGDataType.color3f, connection: in8),
                .init(name: "in9", dataType: SGDataType.color3f, connection: in9),
                .init(name: "in10", dataType: SGDataType.color3f, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) && SGDataType.color4f.matches(in3) && SGDataType.color4f.matches(in4) && SGDataType.color4f.matches(in5) && SGDataType.color4f.matches(in6) && SGDataType.color4f.matches(in7) && SGDataType.color4f.matches(in8) && SGDataType.color4f.matches(in9) && SGDataType.color4f.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
                .init(name: "in3", dataType: SGDataType.color4f, connection: in3),
                .init(name: "in4", dataType: SGDataType.color4f, connection: in4),
                .init(name: "in5", dataType: SGDataType.color4f, connection: in5),
                .init(name: "in6", dataType: SGDataType.color4f, connection: in6),
                .init(name: "in7", dataType: SGDataType.color4f, connection: in7),
                .init(name: "in8", dataType: SGDataType.color4f, connection: in8),
                .init(name: "in9", dataType: SGDataType.color4f, connection: in9),
                .init(name: "in10", dataType: SGDataType.color4f, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.color4f.matches(in1) && SGDataType.color4f.matches(in2) && SGDataType.color4f.matches(in3) && SGDataType.color4f.matches(in4) && SGDataType.color4f.matches(in5) && SGDataType.color4f.matches(in6) && SGDataType.color4f.matches(in7) && SGDataType.color4f.matches(in8) && SGDataType.color4f.matches(in9) && SGDataType.color4f.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4I",
            inputs: [
                .init(name: "in1", dataType: SGDataType.color4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.color4f, connection: in2),
                .init(name: "in3", dataType: SGDataType.color4f, connection: in3),
                .init(name: "in4", dataType: SGDataType.color4f, connection: in4),
                .init(name: "in5", dataType: SGDataType.color4f, connection: in5),
                .init(name: "in6", dataType: SGDataType.color4f, connection: in6),
                .init(name: "in7", dataType: SGDataType.color4f, connection: in7),
                .init(name: "in8", dataType: SGDataType.color4f, connection: in8),
                .init(name: "in9", dataType: SGDataType.color4f, connection: in9),
                .init(name: "in10", dataType: SGDataType.color4f, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) && SGDataType.float.matches(in3) && SGDataType.float.matches(in4) && SGDataType.float.matches(in5) && SGDataType.float.matches(in6) && SGDataType.float.matches(in7) && SGDataType.float.matches(in8) && SGDataType.float.matches(in9) && SGDataType.float.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_float",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
                .init(name: "in3", dataType: SGDataType.float, connection: in3),
                .init(name: "in4", dataType: SGDataType.float, connection: in4),
                .init(name: "in5", dataType: SGDataType.float, connection: in5),
                .init(name: "in6", dataType: SGDataType.float, connection: in6),
                .init(name: "in7", dataType: SGDataType.float, connection: in7),
                .init(name: "in8", dataType: SGDataType.float, connection: in8),
                .init(name: "in9", dataType: SGDataType.float, connection: in9),
                .init(name: "in10", dataType: SGDataType.float, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.float.matches(in1) && SGDataType.float.matches(in2) && SGDataType.float.matches(in3) && SGDataType.float.matches(in4) && SGDataType.float.matches(in5) && SGDataType.float.matches(in6) && SGDataType.float.matches(in7) && SGDataType.float.matches(in8) && SGDataType.float.matches(in9) && SGDataType.float.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_floatI",
            inputs: [
                .init(name: "in1", dataType: SGDataType.float, connection: in1),
                .init(name: "in2", dataType: SGDataType.float, connection: in2),
                .init(name: "in3", dataType: SGDataType.float, connection: in3),
                .init(name: "in4", dataType: SGDataType.float, connection: in4),
                .init(name: "in5", dataType: SGDataType.float, connection: in5),
                .init(name: "in6", dataType: SGDataType.float, connection: in6),
                .init(name: "in7", dataType: SGDataType.float, connection: in7),
                .init(name: "in8", dataType: SGDataType.float, connection: in8),
                .init(name: "in9", dataType: SGDataType.float, connection: in9),
                .init(name: "in10", dataType: SGDataType.float, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) && SGDataType.half.matches(in3) && SGDataType.half.matches(in4) && SGDataType.half.matches(in5) && SGDataType.half.matches(in6) && SGDataType.half.matches(in7) && SGDataType.half.matches(in8) && SGDataType.half.matches(in9) && SGDataType.half.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_half",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
                .init(name: "in3", dataType: SGDataType.half, connection: in3),
                .init(name: "in4", dataType: SGDataType.half, connection: in4),
                .init(name: "in5", dataType: SGDataType.half, connection: in5),
                .init(name: "in6", dataType: SGDataType.half, connection: in6),
                .init(name: "in7", dataType: SGDataType.half, connection: in7),
                .init(name: "in8", dataType: SGDataType.half, connection: in8),
                .init(name: "in9", dataType: SGDataType.half, connection: in9),
                .init(name: "in10", dataType: SGDataType.half, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.half.matches(in1) && SGDataType.half.matches(in2) && SGDataType.half.matches(in3) && SGDataType.half.matches(in4) && SGDataType.half.matches(in5) && SGDataType.half.matches(in6) && SGDataType.half.matches(in7) && SGDataType.half.matches(in8) && SGDataType.half.matches(in9) && SGDataType.half.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_halfI",
            inputs: [
                .init(name: "in1", dataType: SGDataType.half, connection: in1),
                .init(name: "in2", dataType: SGDataType.half, connection: in2),
                .init(name: "in3", dataType: SGDataType.half, connection: in3),
                .init(name: "in4", dataType: SGDataType.half, connection: in4),
                .init(name: "in5", dataType: SGDataType.half, connection: in5),
                .init(name: "in6", dataType: SGDataType.half, connection: in6),
                .init(name: "in7", dataType: SGDataType.half, connection: in7),
                .init(name: "in8", dataType: SGDataType.half, connection: in8),
                .init(name: "in9", dataType: SGDataType.half, connection: in9),
                .init(name: "in10", dataType: SGDataType.half, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) && SGDataType.vector2f.matches(in3) && SGDataType.vector2f.matches(in4) && SGDataType.vector2f.matches(in5) && SGDataType.vector2f.matches(in6) && SGDataType.vector2f.matches(in7) && SGDataType.vector2f.matches(in8) && SGDataType.vector2f.matches(in9) && SGDataType.vector2f.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
                .init(name: "in3", dataType: SGDataType.vector2f, connection: in3),
                .init(name: "in4", dataType: SGDataType.vector2f, connection: in4),
                .init(name: "in5", dataType: SGDataType.vector2f, connection: in5),
                .init(name: "in6", dataType: SGDataType.vector2f, connection: in6),
                .init(name: "in7", dataType: SGDataType.vector2f, connection: in7),
                .init(name: "in8", dataType: SGDataType.vector2f, connection: in8),
                .init(name: "in9", dataType: SGDataType.vector2f, connection: in9),
                .init(name: "in10", dataType: SGDataType.vector2f, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.vector2f.matches(in2) && SGDataType.vector2f.matches(in3) && SGDataType.vector2f.matches(in4) && SGDataType.vector2f.matches(in5) && SGDataType.vector2f.matches(in6) && SGDataType.vector2f.matches(in7) && SGDataType.vector2f.matches(in8) && SGDataType.vector2f.matches(in9) && SGDataType.vector2f.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2I",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector2f, connection: in2),
                .init(name: "in3", dataType: SGDataType.vector2f, connection: in3),
                .init(name: "in4", dataType: SGDataType.vector2f, connection: in4),
                .init(name: "in5", dataType: SGDataType.vector2f, connection: in5),
                .init(name: "in6", dataType: SGDataType.vector2f, connection: in6),
                .init(name: "in7", dataType: SGDataType.vector2f, connection: in7),
                .init(name: "in8", dataType: SGDataType.vector2f, connection: in8),
                .init(name: "in9", dataType: SGDataType.vector2f, connection: in9),
                .init(name: "in10", dataType: SGDataType.vector2f, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) && SGDataType.vector3f.matches(in3) && SGDataType.vector3f.matches(in4) && SGDataType.vector3f.matches(in5) && SGDataType.vector3f.matches(in6) && SGDataType.vector3f.matches(in7) && SGDataType.vector3f.matches(in8) && SGDataType.vector3f.matches(in9) && SGDataType.vector3f.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
                .init(name: "in3", dataType: SGDataType.vector3f, connection: in3),
                .init(name: "in4", dataType: SGDataType.vector3f, connection: in4),
                .init(name: "in5", dataType: SGDataType.vector3f, connection: in5),
                .init(name: "in6", dataType: SGDataType.vector3f, connection: in6),
                .init(name: "in7", dataType: SGDataType.vector3f, connection: in7),
                .init(name: "in8", dataType: SGDataType.vector3f, connection: in8),
                .init(name: "in9", dataType: SGDataType.vector3f, connection: in9),
                .init(name: "in10", dataType: SGDataType.vector3f, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.vector3f.matches(in2) && SGDataType.vector3f.matches(in3) && SGDataType.vector3f.matches(in4) && SGDataType.vector3f.matches(in5) && SGDataType.vector3f.matches(in6) && SGDataType.vector3f.matches(in7) && SGDataType.vector3f.matches(in8) && SGDataType.vector3f.matches(in9) && SGDataType.vector3f.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3I",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector3f, connection: in2),
                .init(name: "in3", dataType: SGDataType.vector3f, connection: in3),
                .init(name: "in4", dataType: SGDataType.vector3f, connection: in4),
                .init(name: "in5", dataType: SGDataType.vector3f, connection: in5),
                .init(name: "in6", dataType: SGDataType.vector3f, connection: in6),
                .init(name: "in7", dataType: SGDataType.vector3f, connection: in7),
                .init(name: "in8", dataType: SGDataType.vector3f, connection: in8),
                .init(name: "in9", dataType: SGDataType.vector3f, connection: in9),
                .init(name: "in10", dataType: SGDataType.vector3f, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) && SGDataType.vector4f.matches(in3) && SGDataType.vector4f.matches(in4) && SGDataType.vector4f.matches(in5) && SGDataType.vector4f.matches(in6) && SGDataType.vector4f.matches(in7) && SGDataType.vector4f.matches(in8) && SGDataType.vector4f.matches(in9) && SGDataType.vector4f.matches(in10) && SGDataType.float.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
                .init(name: "in3", dataType: SGDataType.vector4f, connection: in3),
                .init(name: "in4", dataType: SGDataType.vector4f, connection: in4),
                .init(name: "in5", dataType: SGDataType.vector4f, connection: in5),
                .init(name: "in6", dataType: SGDataType.vector4f, connection: in6),
                .init(name: "in7", dataType: SGDataType.vector4f, connection: in7),
                .init(name: "in8", dataType: SGDataType.vector4f, connection: in8),
                .init(name: "in9", dataType: SGDataType.vector4f, connection: in9),
                .init(name: "in10", dataType: SGDataType.vector4f, connection: in10),
                .init(name: "which", dataType: SGDataType.float, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.vector4f.matches(in2) && SGDataType.vector4f.matches(in3) && SGDataType.vector4f.matches(in4) && SGDataType.vector4f.matches(in5) && SGDataType.vector4f.matches(in6) && SGDataType.vector4f.matches(in7) && SGDataType.vector4f.matches(in8) && SGDataType.vector4f.matches(in9) && SGDataType.vector4f.matches(in10) && SGDataType.int.matches(which) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4I",
            inputs: [
                .init(name: "in1", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "in2", dataType: SGDataType.vector4f, connection: in2),
                .init(name: "in3", dataType: SGDataType.vector4f, connection: in3),
                .init(name: "in4", dataType: SGDataType.vector4f, connection: in4),
                .init(name: "in5", dataType: SGDataType.vector4f, connection: in5),
                .init(name: "in6", dataType: SGDataType.vector4f, connection: in6),
                .init(name: "in7", dataType: SGDataType.vector4f, connection: in7),
                .init(name: "in8", dataType: SGDataType.vector4f, connection: in8),
                .init(name: "in9", dataType: SGDataType.vector4f, connection: in9),
                .init(name: "in10", dataType: SGDataType.vector4f, connection: in10),
                .init(name: "which", dataType: SGDataType.int, connection: which),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in switchValue(in1: \(in1.dataType), in2: \(in2.dataType), in3: \(in3.dataType), in4: \(in4.dataType), in5: \(in5.dataType), in6: \(in6.dataType), in7: \(in7.dataType), in8: \(in8.dataType), in9: \(in9.dataType), in10: \(in10.dataType), which: \(which?.dataType.rawValue ?? "nil"))", values: [in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, which]))
}
/// Tan
public func tan<T>(_ in1: T) -> T where T: SGNumeric {
    if SGDataType.float.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_float",
            inputs: [
                .init(name: "in", dataType: SGDataType.float, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half",
            inputs: [
                .init(name: "in", dataType: SGDataType.half, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if SGDataType.vector3h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if SGDataType.vector4h.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4h, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if SGDataType.vector2f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in tan(in1: \(in1.dataType))", values: [in1]))
}
/// Tiled Image
public func tiledImage<T>(file: SGTexture, defaultValue: T, texcoord: SGVector? = nil, uvtiling: SGVector? = nil, uvoffset: SGVector? = nil, realworldimagesize: SGVector? = nil, realworldtilesize: SGVector? = nil, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
    guard SGDataType.asset.matches(file) else {
        return T(source: .error("Invalid tiledImage input. Expected file data type to be SGDataType.asset, but got \(file.dataType).", values: [file]))
    }
    guard SGDataType.vector2f.matches(texcoord) else {
        return T(source: .error("Invalid tiledImage input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.vector2f.matches(uvtiling) else {
        return T(source: .error("Invalid tiledImage input. Expected uvtiling data type to be SGDataType.vector2f, but got \(uvtiling?.dataType.rawValue ?? "nil").", values: [uvtiling]))
    }
    guard SGDataType.vector2f.matches(uvoffset) else {
        return T(source: .error("Invalid tiledImage input. Expected uvoffset data type to be SGDataType.vector2f, but got \(uvoffset?.dataType.rawValue ?? "nil").", values: [uvoffset]))
    }
    guard SGDataType.vector2f.matches(realworldimagesize) else {
        return T(source: .error("Invalid tiledImage input. Expected realworldimagesize data type to be SGDataType.vector2f, but got \(realworldimagesize?.dataType.rawValue ?? "nil").", values: [realworldimagesize]))
    }
    guard SGDataType.vector2f.matches(realworldtilesize) else {
        return T(source: .error("Invalid tiledImage input. Expected realworldtilesize data type to be SGDataType.vector2f, but got \(realworldtilesize?.dataType.rawValue ?? "nil").", values: [realworldtilesize]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_float",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.float, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.half.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_half",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.half, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if SGDataType.vector2f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector2",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector2f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector3",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector3f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector4",
            inputs: [
                .init(name: "file", dataType: SGDataType.asset, connection: file),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
                .init(name: "uvtiling", dataType: SGDataType.vector2f, connection: uvtiling),
                .init(name: "uvoffset", dataType: SGDataType.vector2f, connection: uvoffset),
                .init(name: "realworldimagesize", dataType: SGDataType.vector2f, connection: realworldimagesize),
                .init(name: "realworldtilesize", dataType: SGDataType.vector2f, connection: realworldtilesize),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in tiledImage(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Transform Matrix
public func transformMatrix(_ in1: SGVector, mat: SGMatrix) -> SGVector {
    if SGDataType.vector2f.matches(in1) && SGDataType.matrix2d.matches(mat) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector2",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "mat", dataType: SGDataType.matrix2d, connection: mat),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector2f.matches(in1) && SGDataType.matrix3d.matches(mat) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector2M3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector2f, connection: in1),
                .init(name: "mat", dataType: SGDataType.matrix3d, connection: mat),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.matrix3d.matches(mat) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector3",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "mat", dataType: SGDataType.matrix3d, connection: mat),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector3f.matches(in1) && SGDataType.matrix4d.matches(mat) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector3M4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
                .init(name: "mat", dataType: SGDataType.matrix4d, connection: mat),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(in1) && SGDataType.matrix4d.matches(mat) {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector4",
            inputs: [
                .init(name: "in", dataType: SGDataType.vector4f, connection: in1),
                .init(name: "mat", dataType: SGDataType.matrix4d, connection: mat),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGVector(source: .error("Unsupported input data types in transformMatrix(in1: \(in1.dataType), mat: \(mat.dataType))", values: [in1, mat]))
}
/// Transform Normal
public func transformNormal(_ in1: SGVector, fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid transformNormal input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformnormal_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            .init(name: "fromspace", dataType: SGDataType.string, connection: SGString(source: .constant(.string(fromspace.rawValue)))),
            .init(name: "tospace", dataType: SGDataType.string, connection: SGString(source: .constant(.string(tospace.rawValue)))),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Transform Point
public func transformPoint(_ in1: SGVector, fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid transformPoint input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformpoint_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            .init(name: "fromspace", dataType: SGDataType.string, connection: SGString(source: .constant(.string(fromspace.rawValue)))),
            .init(name: "tospace", dataType: SGDataType.string, connection: SGString(source: .constant(.string(tospace.rawValue)))),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Transform Vector
public func transformVector(_ in1: SGVector, fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
    guard SGDataType.vector3f.matches(in1) else {
        return SGVector(source: .error("Invalid transformVector input. Expected in1 data type to be SGDataType.vector3f, but got \(in1.dataType).", values: [in1]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformvector_vector3",
        inputs: [
            .init(name: "in", dataType: SGDataType.vector3f, connection: in1),
            .init(name: "fromspace", dataType: SGDataType.string, connection: SGString(source: .constant(.string(fromspace.rawValue)))),
            .init(name: "tospace", dataType: SGDataType.string, connection: SGString(source: .constant(.string(tospace.rawValue)))),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Transpose
public func transpose(_ in1: SGMatrix) -> SGMatrix {
    if SGDataType.matrix2d.matches(in1) {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix22",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix2d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if SGDataType.matrix3d.matches(in1) {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix33",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix3d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if SGDataType.matrix4d.matches(in1) {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix44",
            inputs: [
                .init(name: "in", dataType: SGDataType.matrix4d, connection: in1),
            ],
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    return SGMatrix(source: .error("Unsupported input data types in transpose(in1: \(in1.dataType))", values: [in1]))
}
/// Triplanar Projection
public func triplanarProjection<T>(filex: SGTexture, filey: SGTexture, filez: SGTexture, defaultValue: T, position: SGVector? = nil, normal: SGVector? = nil, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
    guard SGDataType.asset.matches(filex) else {
        return T(source: .error("Invalid triplanarProjection input. Expected filex data type to be SGDataType.asset, but got \(filex.dataType).", values: [filex]))
    }
    guard SGDataType.asset.matches(filey) else {
        return T(source: .error("Invalid triplanarProjection input. Expected filey data type to be SGDataType.asset, but got \(filey.dataType).", values: [filey]))
    }
    guard SGDataType.asset.matches(filez) else {
        return T(source: .error("Invalid triplanarProjection input. Expected filez data type to be SGDataType.asset, but got \(filez.dataType).", values: [filez]))
    }
    guard SGDataType.vector3f.matches(position) else {
        return T(source: .error("Invalid triplanarProjection input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    guard SGDataType.vector3f.matches(normal) else {
        return T(source: .error("Invalid triplanarProjection input. Expected normal data type to be SGDataType.vector3f, but got \(normal?.dataType.rawValue ?? "nil").", values: [normal]))
    }
    if SGDataType.color3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color3",
            inputs: [
                .init(name: "filex", dataType: SGDataType.asset, connection: filex),
                .init(name: "filey", dataType: SGDataType.asset, connection: filey),
                .init(name: "filez", dataType: SGDataType.asset, connection: filez),
                .init(name: "default", dataType: SGDataType.color3f, connection: defaultValue),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if SGDataType.color4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color4",
            inputs: [
                .init(name: "filex", dataType: SGDataType.asset, connection: filex),
                .init(name: "filey", dataType: SGDataType.asset, connection: filey),
                .init(name: "filez", dataType: SGDataType.asset, connection: filez),
                .init(name: "default", dataType: SGDataType.color4f, connection: defaultValue),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if SGDataType.float.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_float",
            inputs: [
                .init(name: "filex", dataType: SGDataType.asset, connection: filex),
                .init(name: "filey", dataType: SGDataType.asset, connection: filey),
                .init(name: "filez", dataType: SGDataType.asset, connection: filez),
                .init(name: "default", dataType: SGDataType.float, connection: defaultValue),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if SGDataType.vector2f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector2",
            inputs: [
                .init(name: "filex", dataType: SGDataType.asset, connection: filex),
                .init(name: "filey", dataType: SGDataType.asset, connection: filey),
                .init(name: "filez", dataType: SGDataType.asset, connection: filez),
                .init(name: "default", dataType: SGDataType.vector2f, connection: defaultValue),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if SGDataType.vector3f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector3",
            inputs: [
                .init(name: "filex", dataType: SGDataType.asset, connection: filex),
                .init(name: "filey", dataType: SGDataType.asset, connection: filey),
                .init(name: "filez", dataType: SGDataType.asset, connection: filez),
                .init(name: "default", dataType: SGDataType.vector3f, connection: defaultValue),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if SGDataType.vector4f.matches(defaultValue) {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector4",
            inputs: [
                .init(name: "filex", dataType: SGDataType.asset, connection: filex),
                .init(name: "filey", dataType: SGDataType.asset, connection: filey),
                .init(name: "filez", dataType: SGDataType.asset, connection: filez),
                .init(name: "default", dataType: SGDataType.vector4f, connection: defaultValue),
                .init(name: "position", dataType: SGDataType.vector3f, connection: position),
                .init(name: "normal", dataType: SGDataType.vector3f, connection: normal),
                .init(name: "filtertype", dataType: SGDataType.string, connection: SGString(source: .constant(.string(filtertype.rawValue)))),
            ],
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types in triplanarProjection(defaultValue: \(defaultValue.dataType))", values: [defaultValue]))
}
/// Unpremultiply
public func unpremult(_ in1: SGColor) -> SGColor {
    guard SGDataType.color4f.matches(in1) else {
        return SGColor(source: .error("Invalid unpremult input. Expected in1 data type to be SGDataType.color4f, but got \(in1.dataType).", values: [in1]))
    }
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_unpremult_color4",
        inputs: [
            .init(name: "in", dataType: SGDataType.color4f, connection: in1),
        ],
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Worley Noise 2D
public func worleyNoise2DFloat(texcoord: SGVector? = nil, jitter: SGScalar? = nil) -> SGScalar {
    guard SGDataType.vector2f.matches(texcoord) else {
        return SGScalar(source: .error("Invalid worleyNoise2DFloat input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(jitter) else {
        return SGScalar(source: .error("Invalid worleyNoise2DFloat input. Expected jitter data type to be SGDataType.float, but got \(jitter?.dataType.rawValue ?? "nil").", values: [jitter]))
    }
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_float",
        inputs: [
            .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            .init(name: "jitter", dataType: SGDataType.float, connection: jitter),
        ],
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Worley Noise 2D
public func worleyNoise2DVector2(texcoord: SGVector? = nil, jitter: SGScalar? = nil) -> SGVector {
    guard SGDataType.vector2f.matches(texcoord) else {
        return SGVector(source: .error("Invalid worleyNoise2DVector2 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(jitter) else {
        return SGVector(source: .error("Invalid worleyNoise2DVector2 input. Expected jitter data type to be SGDataType.float, but got \(jitter?.dataType.rawValue ?? "nil").", values: [jitter]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_vector2",
        inputs: [
            .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            .init(name: "jitter", dataType: SGDataType.float, connection: jitter),
        ],
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Worley Noise 2D
public func worleyNoise2DVector3(texcoord: SGVector? = nil, jitter: SGScalar? = nil) -> SGVector {
    guard SGDataType.vector2f.matches(texcoord) else {
        return SGVector(source: .error("Invalid worleyNoise2DVector3 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord?.dataType.rawValue ?? "nil").", values: [texcoord]))
    }
    guard SGDataType.float.matches(jitter) else {
        return SGVector(source: .error("Invalid worleyNoise2DVector3 input. Expected jitter data type to be SGDataType.float, but got \(jitter?.dataType.rawValue ?? "nil").", values: [jitter]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_vector3",
        inputs: [
            .init(name: "texcoord", dataType: SGDataType.vector2f, connection: texcoord),
            .init(name: "jitter", dataType: SGDataType.float, connection: jitter),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Worley Noise 3D
public func worleyNoise3DFloat(position: SGVector? = nil, jitter: SGScalar? = nil) -> SGScalar {
    guard SGDataType.vector3f.matches(position) else {
        return SGScalar(source: .error("Invalid worleyNoise3DFloat input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    guard SGDataType.float.matches(jitter) else {
        return SGScalar(source: .error("Invalid worleyNoise3DFloat input. Expected jitter data type to be SGDataType.float, but got \(jitter?.dataType.rawValue ?? "nil").", values: [jitter]))
    }
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_float",
        inputs: [
            .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            .init(name: "jitter", dataType: SGDataType.float, connection: jitter),
        ],
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Worley Noise 3D
public func worleyNoise3DVector2(position: SGVector? = nil, jitter: SGScalar? = nil) -> SGVector {
    guard SGDataType.vector3f.matches(position) else {
        return SGVector(source: .error("Invalid worleyNoise3DVector2 input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    guard SGDataType.float.matches(jitter) else {
        return SGVector(source: .error("Invalid worleyNoise3DVector2 input. Expected jitter data type to be SGDataType.float, but got \(jitter?.dataType.rawValue ?? "nil").", values: [jitter]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_vector2",
        inputs: [
            .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            .init(name: "jitter", dataType: SGDataType.float, connection: jitter),
        ],
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Worley Noise 3D
public func worleyNoise3DVector3(position: SGVector? = nil, jitter: SGScalar? = nil) -> SGVector {
    guard SGDataType.vector3f.matches(position) else {
        return SGVector(source: .error("Invalid worleyNoise3DVector3 input. Expected position data type to be SGDataType.vector3f, but got \(position?.dataType.rawValue ?? "nil").", values: [position]))
    }
    guard SGDataType.float.matches(jitter) else {
        return SGVector(source: .error("Invalid worleyNoise3DVector3 input. Expected jitter data type to be SGDataType.float, but got \(jitter?.dataType.rawValue ?? "nil").", values: [jitter]))
    }
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_vector3",
        inputs: [
            .init(name: "position", dataType: SGDataType.vector3f, connection: position),
            .init(name: "jitter", dataType: SGDataType.float, connection: jitter),
        ],
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public extension SGValue {
    /// If Equal
    func ifEqual<T>(_ value2: SGValue, trueResult: T, falseResult: T) -> T where T: SGNumeric {
        ShaderGraphCoder.ifEqual(self, value2, trueResult: trueResult, falseResult: falseResult)
    }
    /// And
    func logicalAnd(_ in2: SGValue) -> SGValue {
        ShaderGraphCoder.logicalAnd(self, in2)
    }
    /// Not
    func logicalNot() -> SGValue {
        ShaderGraphCoder.logicalNot(self)
    }
    /// Or
    func logicalOr(_ in2: SGValue) -> SGValue {
        ShaderGraphCoder.logicalOr(self, in2)
    }
    /// XOR
    func logicalXor(_ in2: SGValue) -> SGValue {
        ShaderGraphCoder.logicalXor(self, in2)
    }
}
public extension SGNumeric {
    /// Abs
    func abs() -> Self {
        ShaderGraphCoder.abs(self)
    }
    /// Acos
    func acos() -> Self {
        ShaderGraphCoder.acos(self)
    }
    /// Add
    func add(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.add(self, in2)
    }
    /// Asin
    func asin() -> Self {
        ShaderGraphCoder.asin(self)
    }
    /// Atan2
    func atan2(inx: SGNumeric) -> Self {
        ShaderGraphCoder.atan2(iny: self, inx: inx) as! Self
    }
    /// Blur
    func blur(size: SGScalar? = nil, filtertype: SGBlurFilterType = SGBlurFilterType.box) -> Self {
        ShaderGraphCoder.blur(self, size: size, filtertype: filtertype)
    }
    /// Burn
    func burn(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.burn(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Ceiling
    func ceil() -> Self {
        ShaderGraphCoder.ceil(self)
    }
    /// Clamp
    func clamp(min: SGNumeric, max: SGNumeric) -> Self {
        ShaderGraphCoder.clamp(self, min: min, max: max)
    }
    /// Contrast
    func contrast(amount: SGNumeric, pivot: SGNumeric) -> Self {
        ShaderGraphCoder.contrast(self, amount: amount, pivot: pivot)
    }
    /// Cos
    func cos() -> Self {
        ShaderGraphCoder.cos(self)
    }
    /// Difference
    func difference(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.difference(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Divide
    func divide(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.divide(self, in2)
    }
    /// Dodge
    func dodge(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.dodge(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Exp
    func exp() -> Self {
        ShaderGraphCoder.exp(self)
    }
    /// Floor
    func floor() -> Self {
        ShaderGraphCoder.floor(self)
    }
    /// Fractional
    func fract() -> Self {
        ShaderGraphCoder.fract(self)
    }
    /// Fractal Noise 3D
    func fractal3D(octaves: SGScalar? = nil, lacunarity: SGScalar? = nil, diminish: SGScalar? = nil, position: SGVector? = nil) -> SGNumeric {
        ShaderGraphCoder.fractal3D(amplitude: self, octaves: octaves, lacunarity: lacunarity, diminish: diminish, position: position)
    }
    /// Camera Index Switch
    func geometrySwitchCameraindex(left: SGNumeric, right: SGNumeric) -> Self {
        ShaderGraphCoder.geometrySwitchCameraindex(mono: self, left: left, right: right) as! Self
    }
    /// Inside
    func inside(mask: SGScalar? = nil) -> Self {
        ShaderGraphCoder.inside(self, mask: mask)
    }
    /// Natural Log
    func log() -> Self {
        ShaderGraphCoder.log(self)
    }
    /// Max
    func max(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.max(self, in2)
    }
    /// Min
    func min(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.min(self, in2)
    }
    /// Subtractive Mix
    func minus(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.minus(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Mix
    func mix(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.mix(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Modulo
    func modulo(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.modulo(self, in2)
    }
    /// Multiply
    func multiply(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.multiply(self, in2)
    }
    /// Noise 2D
    func noise2D(pivot: SGScalar? = nil, texcoord: SGVector? = nil) -> SGNumeric {
        ShaderGraphCoder.noise2D(amplitude: self, pivot: pivot, texcoord: texcoord)
    }
    /// Noise 3D
    func noise3D(pivot: SGScalar? = nil, position: SGVector? = nil) -> SGNumeric {
        ShaderGraphCoder.noise3D(amplitude: self, pivot: pivot, position: position)
    }
    /// One Minus
    func oneMinus() -> Self {
        ShaderGraphCoder.oneMinus(self)
    }
    /// Outside
    func outside(mask: SGScalar? = nil) -> Self {
        ShaderGraphCoder.outside(self, mask: mask)
    }
    /// Overlay
    func overlay(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.overlay(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Additive Mix
    func plus(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.plus(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Power
    func pow(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.pow(self, in2)
    }
    /// Ramp 4 Corners
    func ramp4(valuetr: SGNumeric, valuebl: SGNumeric, valuebr: SGNumeric, texcoord: SGVector? = nil) -> Self {
        ShaderGraphCoder.ramp4(valuetl: self, valuetr: valuetr, valuebl: valuebl, valuebr: valuebr, texcoord: texcoord) as! Self
    }
    /// Ramp Horizontal
    func ramplr(valuer: SGNumeric, texcoord: SGVector? = nil) -> Self {
        ShaderGraphCoder.ramplr(valuel: self, valuer: valuer, texcoord: texcoord) as! Self
    }
    /// Ramp Vertical
    func ramptb(valueb: SGNumeric, texcoord: SGVector? = nil) -> Self {
        ShaderGraphCoder.ramptb(valuet: self, valueb: valueb, texcoord: texcoord) as! Self
    }
    /// Range
    func range(inlow: SGNumeric, inhigh: SGNumeric, gamma: SGNumeric, outlow: SGNumeric, outhigh: SGNumeric, doclamp: SGValue? = nil) -> Self {
        ShaderGraphCoder.range(self, inlow: inlow, inhigh: inhigh, gamma: gamma, outlow: outlow, outhigh: outhigh, doclamp: doclamp)
    }
    /// Remap
    func remap(inlow: SGNumeric, inhigh: SGNumeric, outlow: SGNumeric, outhigh: SGNumeric) -> Self {
        ShaderGraphCoder.remap(self, inlow: inlow, inhigh: inhigh, outlow: outlow, outhigh: outhigh)
    }
    /// Round
    func round() -> Self {
        ShaderGraphCoder.round(self)
    }
    /// Safe Power
    func safePow(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.safePow(self, in2)
    }
    /// Screen
    func screen(bg: SGNumeric, mix: SGScalar? = nil) -> Self {
        ShaderGraphCoder.screen(fg: self, bg: bg, mix: mix) as! Self
    }
    /// Sign
    func sign() -> Self {
        ShaderGraphCoder.sign(self)
    }
    /// Sin
    func sin() -> Self {
        ShaderGraphCoder.sin(self)
    }
    /// Smooth Step
    func smoothStep(low: SGNumeric, high: SGNumeric) -> Self {
        ShaderGraphCoder.smoothStep(self, low: low, high: high)
    }
    /// Split Horizontal
    func splitlr(valuer: SGNumeric, center: SGScalar? = nil, texcoord: SGVector? = nil) -> Self {
        ShaderGraphCoder.splitlr(valuel: self, valuer: valuer, center: center, texcoord: texcoord) as! Self
    }
    /// Split Vertical
    func splittb(valueb: SGNumeric, center: SGScalar? = nil, texcoord: SGVector? = nil) -> Self {
        ShaderGraphCoder.splittb(valuet: self, valueb: valueb, center: center, texcoord: texcoord) as! Self
    }
    /// Square Root
    func sqrt() -> Self {
        ShaderGraphCoder.sqrt(self)
    }
    /// Step
    func step(edge: SGNumeric) -> Self {
        ShaderGraphCoder.step(self, edge: edge) as! Self
    }
    /// Subtract
    func subtract(_ in2: SGNumeric) -> Self {
        ShaderGraphCoder.subtract(self, in2)
    }
    /// Switch
    func switchValue(_ in2: SGNumeric, _ in3: SGNumeric, _ in4: SGNumeric, _ in5: SGNumeric, _ in6: SGNumeric, _ in7: SGNumeric, _ in8: SGNumeric, _ in9: SGNumeric, _ in10: SGNumeric, which: SGScalar? = nil) -> Self {
        ShaderGraphCoder.switchValue(self, in2, in3, in4, in5, in6, in7, in8, in9, in10, which: which) as! Self
    }
    /// Tan
    func tan() -> Self {
        ShaderGraphCoder.tan(self)
    }
}
public extension SGScalar {
    /// Ambient Occlusion
    func ambientOcclusion(maxdistance: SGScalar? = nil) -> SGScalar {
        ShaderGraphCoder.ambientOcclusion(coneangle: self, maxdistance: maxdistance)
    }
    /// Height To Normal
    func heightToNormal(scale: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.heightToNormal(self, scale: scale)
    }
    /// If Greater
    func ifGreater<T>(_ value2: SGScalar, trueResult: T, falseResult: T) -> T where T: SGNumeric {
        ShaderGraphCoder.ifGreater(self, value2, trueResult: trueResult, falseResult: falseResult)
    }
    /// If Greater Or Equal
    func ifGreaterOrEqual<T>(_ value2: SGScalar, trueResult: T, falseResult: T) -> T where T: SGNumeric {
        ShaderGraphCoder.ifGreaterOrEqual(self, value2, trueResult: trueResult, falseResult: falseResult)
    }
}
public extension SGColor {
    /// Disjoint Over
    func disjointover(bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
        ShaderGraphCoder.disjointover(fg: self, bg: bg, mix: mix)
    }
    /// HSV Adjust
    func hsvAdjust(amount: SGVector? = nil) -> SGColor {
        ShaderGraphCoder.hsvAdjust(self, amount: amount)
    }
    /// HSV to RGB
    func hsvToRGB() -> SGColor {
        ShaderGraphCoder.hsvToRGB(self)
    }
    /// Luminance
    func luminance(lumacoeffs: SGColor? = nil) -> SGColor {
        ShaderGraphCoder.luminance(self, lumacoeffs: lumacoeffs)
    }
    /// Mask
    func mask(bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
        ShaderGraphCoder.mask(fg: self, bg: bg, mix: mix)
    }
    /// Matte
    func matte(bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
        ShaderGraphCoder.matte(fg: self, bg: bg, mix: mix)
    }
    /// In
    func mixColor(bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
        ShaderGraphCoder.mixColor(fg: self, bg: bg, mix: mix)
    }
    /// Out
    func out(bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
        ShaderGraphCoder.out(fg: self, bg: bg, mix: mix)
    }
    /// Over
    func over(bg: SGColor? = nil, mix: SGScalar? = nil) -> SGColor {
        ShaderGraphCoder.over(fg: self, bg: bg, mix: mix)
    }
    /// Premultiply
    func premult() -> SGColor {
        ShaderGraphCoder.premult(self)
    }
    /// RGB to HSV
    func rgbToHSV() -> SGColor {
        ShaderGraphCoder.rgbToHSV(self)
    }
    /// Saturate
    func saturate(amount: SGScalar? = nil, lumacoeffs: SGColor? = nil) -> SGColor {
        ShaderGraphCoder.saturate(self, amount: amount, lumacoeffs: lumacoeffs)
    }
    /// Unpremultiply
    func unpremult() -> SGColor {
        ShaderGraphCoder.unpremult(self)
    }
}
public extension SGVector {
    /// Cellular Noise 2D
    func cellNoise2D() -> SGScalar {
        ShaderGraphCoder.cellNoise2D(texcoord: self)
    }
    /// Cellular Noise 3D
    func cellNoise3D() -> SGScalar {
        ShaderGraphCoder.cellNoise3D(position: self)
    }
    /// Cross Product
    func cross(_ in2: SGVector) -> SGVector {
        ShaderGraphCoder.cross(self, in2)
    }
    /// Dot Product
    func dot(_ in2: SGVector) -> SGScalar {
        ShaderGraphCoder.dot(self, in2)
    }
    /// Magnitude
    func length() -> SGScalar {
        ShaderGraphCoder.length(self)
    }
    /// Normal Map
    func normalMap(space: SGNormalSpace = SGNormalSpace.tangent, scale: SGNumeric, normal: SGVector? = nil, tangent: SGVector? = nil) -> SGVector {
        ShaderGraphCoder.normalMap(self, space: space, scale: scale, normal: normal, tangent: tangent)
    }
    /// Normal Map Decode
    func normalMapDecode() -> SGVector {
        ShaderGraphCoder.normalMapDecode(self)
    }
    /// Normalize
    func normalize() -> SGVector {
        ShaderGraphCoder.normalize(self)
    }
    /// Place 2D
    func place2D(pivot: SGVector? = nil, scale: SGVector? = nil, rotate: SGScalar? = nil, offset: SGVector? = nil) -> SGVector {
        ShaderGraphCoder.place2D(texcoord: self, pivot: pivot, scale: scale, rotate: rotate, offset: offset)
    }
    /// Reflect
    func reflect(normal: SGVector? = nil) -> SGVector {
        ShaderGraphCoder.reflect(self, normal: normal)
    }
    /// Refract
    func refract(normal: SGVector? = nil, eta: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.refract(self, normal: normal, eta: eta)
    }
    /// Rotate 2D
    func rotate2D(amount: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.rotate2D(self, amount: amount)
    }
    /// Rotate 3D
    func rotate3D(amount: SGScalar? = nil, axis: SGVector? = nil) -> SGVector {
        ShaderGraphCoder.rotate3D(self, amount: amount, axis: axis)
    }
    /// Transform Matrix
    func transformMatrix(mat: SGMatrix) -> SGVector {
        ShaderGraphCoder.transformMatrix(self, mat: mat)
    }
    /// Transform Normal
    func transformNormal(fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
        ShaderGraphCoder.transformNormal(self, fromspace: fromspace, tospace: tospace)
    }
    /// Transform Point
    func transformPoint(fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
        ShaderGraphCoder.transformPoint(self, fromspace: fromspace, tospace: tospace)
    }
    /// Transform Vector
    func transformVector(fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
        ShaderGraphCoder.transformVector(self, fromspace: fromspace, tospace: tospace)
    }
    /// Worley Noise 2D
    func worleyNoise2DFloat(jitter: SGScalar? = nil) -> SGScalar {
        ShaderGraphCoder.worleyNoise2DFloat(texcoord: self, jitter: jitter)
    }
    /// Worley Noise 2D
    func worleyNoise2DVector2(jitter: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.worleyNoise2DVector2(texcoord: self, jitter: jitter)
    }
    /// Worley Noise 2D
    func worleyNoise2DVector3(jitter: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.worleyNoise2DVector3(texcoord: self, jitter: jitter)
    }
    /// Worley Noise 3D
    func worleyNoise3DFloat(jitter: SGScalar? = nil) -> SGScalar {
        ShaderGraphCoder.worleyNoise3DFloat(position: self, jitter: jitter)
    }
    /// Worley Noise 3D
    func worleyNoise3DVector2(jitter: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.worleyNoise3DVector2(position: self, jitter: jitter)
    }
    /// Worley Noise 3D
    func worleyNoise3DVector3(jitter: SGScalar? = nil) -> SGVector {
        ShaderGraphCoder.worleyNoise3DVector3(position: self, jitter: jitter)
    }
}
public extension SGMatrix {
    /// Determinant
    func determinant() -> SGScalar {
        ShaderGraphCoder.determinant(self)
    }
    /// Invert Matrix
    func invertMatrix() -> SGMatrix {
        ShaderGraphCoder.invertMatrix(self)
    }
    /// Transpose
    func transpose() -> SGMatrix {
        ShaderGraphCoder.transpose(self)
    }
}
public extension SGTexture {
    /// Image
    func image<T>(defaultValue: T, texcoord: SGVector? = nil, uaddressmode: SGImageAddressMode = SGImageAddressMode.periodic, vaddressmode: SGImageAddressMode = SGImageAddressMode.periodic, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
        ShaderGraphCoder.image(file: self, defaultValue: defaultValue, texcoord: texcoord, uaddressmode: uaddressmode, vaddressmode: vaddressmode, filtertype: filtertype)
    }
    /// Image 2D Pixel
    func pixel<T>(uWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, vWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, filter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, bias: SGScalar? = nil, dynamicMinLodClamp: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.pixel(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, filter: filter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, bias: bias, dynamicMinLodClamp: dynamicMinLodClamp, offset: offset)
    }
    /// Image 2D Gradient Pixel
    func pixelGradient<T>(uWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, vWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, filter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, dynamicMinLodClamp: SGScalar? = nil, gradientDpdx: SGVector? = nil, gradientDpdy: SGVector? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.pixelGradient(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, filter: filter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, dynamicMinLodClamp: dynamicMinLodClamp, gradientDpdx: gradientDpdx, gradientDpdy: gradientDpdy, offset: offset)
    }
    /// Image 2D LOD Pixel
    func pixelLOD<T>(uWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, vWrapMode: SGSamplerAddressModeWithoutRepeat = SGSamplerAddressModeWithoutRepeat.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, filter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, lod: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.pixelLOD(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, filter: filter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, lod: lod, offset: offset)
    }
    /// Image 2D Read
    func read<T>(defaultValue: T, x: SGScalar? = nil, y: SGScalar? = nil, lod: SGScalar? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.read(file: self, defaultValue: defaultValue, x: x, y: y, lod: lod)
    }
    /// Image 2D
    func sample<T>(uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, bias: SGScalar? = nil, dynamicMinLodClamp: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.sample(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, magFilter: magFilter, minFilter: minFilter, mipFilter: mipFilter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, bias: bias, dynamicMinLodClamp: dynamicMinLodClamp, offset: offset)
    }
    /// Cube Image
    func sampleCube<T>(uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, bias: SGScalar? = nil, dynamicMinLodClamp: SGScalar? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.sampleCube(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, magFilter: magFilter, minFilter: minFilter, mipFilter: mipFilter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, bias: bias, dynamicMinLodClamp: dynamicMinLodClamp)
    }
    /// Cube Image Gradient
    func sampleCubeGradient<T>(uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, dynamicMinLodClamp: SGScalar? = nil, gradientcubeDpdx: SGVector? = nil, gradientcubeDpdy: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.sampleCubeGradient(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, magFilter: magFilter, minFilter: minFilter, mipFilter: mipFilter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, dynamicMinLodClamp: dynamicMinLodClamp, gradientcubeDpdx: gradientcubeDpdx, gradientcubeDpdy: gradientcubeDpdy)
    }
    /// Cube Image LOD
    func sampleCubeLOD<T>(uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, lod: SGScalar? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.sampleCubeLOD(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, magFilter: magFilter, minFilter: minFilter, mipFilter: mipFilter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, lod: lod)
    }
    /// Image 2D Gradient
    func sampleGradient<T>(uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, dynamicMinLodClamp: SGScalar? = nil, gradientDpdx: SGVector? = nil, gradientDpdy: SGVector? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.sampleGradient(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, magFilter: magFilter, minFilter: minFilter, mipFilter: mipFilter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, dynamicMinLodClamp: dynamicMinLodClamp, gradientDpdx: gradientDpdx, gradientDpdy: gradientDpdy, offset: offset)
    }
    /// Image 2D LOD
    func sampleLOD<T>(uWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, vWrapMode: SGSamplerAddressMode = SGSamplerAddressMode.clampToEdge, borderColor: SGSamplerBorderColor = SGSamplerBorderColor.transparentBlack, magFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, minFilter: SGSamplerMinMagFilter = SGSamplerMinMagFilter.linear, mipFilter: SGSamplerMipFilter = SGSamplerMipFilter.linear, maxAnisotropy: SGScalar? = nil, maxLodClamp: SGScalar? = nil, minLodClamp: SGScalar? = nil, defaultValue: T, texcoord: SGVector? = nil, lod: SGScalar? = nil, offset: SGVector? = nil) -> T where T: SGSIMD {
        ShaderGraphCoder.sampleLOD(file: self, uWrapMode: uWrapMode, vWrapMode: vWrapMode, borderColor: borderColor, magFilter: magFilter, minFilter: minFilter, mipFilter: mipFilter, maxAnisotropy: maxAnisotropy, maxLodClamp: maxLodClamp, minLodClamp: minLodClamp, defaultValue: defaultValue, texcoord: texcoord, lod: lod, offset: offset)
    }
    /// Tiled Image
    func tiledImage<T>(defaultValue: T, texcoord: SGVector? = nil, uvtiling: SGVector? = nil, uvoffset: SGVector? = nil, realworldimagesize: SGVector? = nil, realworldtilesize: SGVector? = nil, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
        ShaderGraphCoder.tiledImage(file: self, defaultValue: defaultValue, texcoord: texcoord, uvtiling: uvtiling, uvoffset: uvoffset, realworldimagesize: realworldimagesize, realworldtilesize: realworldtilesize, filtertype: filtertype)
    }
    /// Triplanar Projection
    func triplanarProjection<T>(filey: SGTexture, filez: SGTexture, defaultValue: T, position: SGVector? = nil, normal: SGVector? = nil, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
        ShaderGraphCoder.triplanarProjection(filex: self, filey: filey, filez: filez, defaultValue: defaultValue, position: position, normal: normal, filtertype: filtertype)
    }
}
