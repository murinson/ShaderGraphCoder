// Autogenerated by opgen.py
import Foundation
import simd
public enum SGSpace: String, CaseIterable {
    case model = "model"
    case object = "object"
    case tangent = "tangent"
    case world = "world"
}
public enum SGBlurFilterType: String, CaseIterable {
    case box = "box"
    case gaussian = "gaussian"
}
public enum SGAddressMode: String, CaseIterable {
    case clamp = "clamp"
    case constant = "constant"
    case mirror = "mirror"
    case periodic = "periodic"
}
public enum SGFilterType: String, CaseIterable {
    case closest = "closest"
    case cubic = "cubic"
    case linear = "linear"
}
public enum SGNormalSpace: String, CaseIterable {
    case object = "object"
    case tangent = "tangent"
}
public enum SGTransformSpace: String, CaseIterable {
    case model = "model"
    case object = "object"
    case unspecified = "unspecified"
    case world = "world"
}
/// Abs
public func abs<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_absval_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for abs"))
}
/// Acos
public func acos<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_acos_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for acos"))
}
/// Add
public func add<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix2d && in2.dataType == SGDataType.matrix2d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix2d && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix22FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix3d && in2.dataType == SGDataType.matrix3d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix3d && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix33FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix4d && in2.dataType == SGDataType.matrix4d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if in1.dataType == SGDataType.matrix4d && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_matrix44FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_add_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for add"))
}
/// Ambient Occlusion
public func ambientocclusion(coneangle: SGScalar = SGScalar(source: .constant(.float(90.0))), maxdistance: SGScalar = SGScalar(source: .constant(.float(9.999999680285692e+37)))) -> SGScalar {
    guard coneangle.dataType == SGDataType.float else {
        return SGScalar(source: .error("Invalid ambientocclusion input. Expected coneangle data type to be SGDataType.float, but got \(coneangle.dataType)."))
    }
    guard maxdistance.dataType == SGDataType.float else {
        return SGScalar(source: .error("Invalid ambientocclusion input. Expected maxdistance data type to be SGDataType.float, but got \(maxdistance.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "coneangle", connection: coneangle),
        .init(name: "maxdistance", connection: maxdistance),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_ambientocclusion_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Asin
public func asin<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_asin_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for asin"))
}
/// Atan2
public func atan2<T>(iny: T, inx: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "iny", connection: iny),
        .init(name: "inx", connection: inx),
    ]
    if iny.dataType == SGDataType.float && inx.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if iny.dataType == SGDataType.half && inx.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if iny.dataType == SGDataType.vector2h && inx.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if iny.dataType == SGDataType.vector3h && inx.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if iny.dataType == SGDataType.vector4h && inx.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if iny.dataType == SGDataType.vector2f && inx.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if iny.dataType == SGDataType.vector3f && inx.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if iny.dataType == SGDataType.vector4f && inx.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_atan2_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for atan2"))
}
/// Blur
public func blur<T>(_ in1: T, size: SGScalar = SGScalar(source: .constant(.float(0.0))), filtertype: SGBlurFilterType = SGBlurFilterType.box) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "size", connection: size),
        .init(name: "filtertype", connection: SGString(source: .constant(.string(filtertype.rawValue)))),
    ]
    if in1.dataType == SGDataType.color3f && size.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && size.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && size.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && size.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && size.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && size.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && size.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_blur_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for blur"))
}
/// Burn
public func burn<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_burn_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for burn"))
}
/// Ceiling
public func ceil<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ceil_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ceil"))
}
public func cellnoise2D(texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> SGScalar {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGScalar(source: .error("Invalid cellnoise2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_cellnoise2d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
public func cellnoise3D(position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0])))) -> SGScalar {
    guard position.dataType == SGDataType.vector3f else {
        return SGScalar(source: .error("Invalid cellnoise3D input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_cellnoise3d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Clamp
public func clamp<T>(_ in1: T, min: SGNumeric, max: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "low", connection: min),
        .init(name: "high", connection: max),
    ]
    if in1.dataType == SGDataType.color3f && min.dataType == SGDataType.color3f && max.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && min.dataType == SGDataType.color4f && max.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && min.dataType == SGDataType.half && max.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && min.dataType == SGDataType.vector2h && max.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && min.dataType == SGDataType.vector3h && max.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && min.dataType == SGDataType.vector4h && max.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && min.dataType == SGDataType.vector2f && max.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && min.dataType == SGDataType.vector3f && max.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && min.dataType == SGDataType.vector4f && max.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && min.dataType == SGDataType.float && max.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_clamp_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for clamp"))
}
/// Contrast
public func contrast<T>(_ in1: T, amount: SGNumeric, pivot: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "amount", connection: amount),
        .init(name: "pivot", connection: pivot),
    ]
    if in1.dataType == SGDataType.color3f && amount.dataType == SGDataType.color3f && pivot.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && amount.dataType == SGDataType.color4f && pivot.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f && amount.dataType == SGDataType.vector2f && pivot.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && amount.dataType == SGDataType.vector3f && pivot.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && amount.dataType == SGDataType.vector4f && pivot.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && amount.dataType == SGDataType.float && pivot.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_contrast_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for contrast"))
}
/// Cos
public func cos<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_cos_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for cos"))
}
/// Cross Product
public func cross(_ in1: SGVector = SGVector(source: .constant(.vector3h([0, 0, 0]))), _ in2: SGVector = SGVector(source: .constant(.vector3h([0, 0, 0])))) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_crossproduct_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGVector(source: .error("Unsupported input data types for cross"))
}
/// Determinant
public func determinant(_ in1: SGMatrix) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.matrix2d {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.matrix3d {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.matrix4d {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_determinant_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types for determinant"))
}
/// Difference
public func difference<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_difference_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for difference"))
}
public func disjointover(fg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), bg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid disjointover input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType)."))
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid disjointover input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType)."))
    }
    guard mix.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid disjointover input. Expected mix data type to be SGDataType.float, but got \(mix.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_disjointover_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Divide
public func divide<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix2d && in2.dataType == SGDataType.matrix2d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix3d && in2.dataType == SGDataType.matrix3d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix4d && in2.dataType == SGDataType.matrix4d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_divide_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for divide"))
}
/// Dodge
public func dodge<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_dodge_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for dodge"))
}
/// Dot Product
public func dot(_ in1: SGVector, _ in2: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_dotproduct_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types for dot"))
}
/// Exp
public func exp<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_exp_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for exp"))
}
/// Extract
public func extract(_ in1: SGSIMD, index: Int = 0) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "index", connection: SGScalar(source: .constant(.int(index)))),
    ]
    if in1.dataType == SGDataType.color3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.color4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_extract_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types for extract"))
}
/// Floor
public func floor<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_floor_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for floor"))
}
/// Fractional
public func fract<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_fractional_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for fract"))
}
/// Fractal Noise 3D
public func fractal3D(amplitude: SGNumeric, octaves: SGScalar = SGScalar(source: .constant(.int(3))), lacunarity: SGScalar = SGScalar(source: .constant(.float(2.0))), diminish: SGScalar = SGScalar(source: .constant(.float(0.5))), position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0])))) -> SGNumeric {
    guard octaves.dataType == SGDataType.int else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected octaves data type to be SGDataType.int, but got \(octaves.dataType)."))
    }
    guard lacunarity.dataType == SGDataType.float else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected lacunarity data type to be SGDataType.float, but got \(lacunarity.dataType)."))
    }
    guard diminish.dataType == SGDataType.float else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected diminish data type to be SGDataType.float, but got \(diminish.dataType)."))
    }
    guard position.dataType == SGDataType.vector3f else {
        return SGNumeric(source: .error("Invalid fractal3D input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "octaves", connection: octaves),
        .init(name: "lacunarity", connection: lacunarity),
        .init(name: "diminish", connection: diminish),
        .init(name: "position", connection: position),
    ]
    if amplitude.dataType == SGDataType.vector3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if amplitude.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_fractal3d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGNumeric(source: .error("Unsupported input data types for fractal3D"))
}
/// Camera Index Switch
public func geometrySwitchCameraindex<T>(mono: T, left: T, right: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "mono", connection: mono),
        .init(name: "left", connection: left),
        .init(name: "right", connection: right),
    ]
    if mono.dataType == SGDataType.color3f && left.dataType == SGDataType.color3f && right.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if mono.dataType == SGDataType.color4f && left.dataType == SGDataType.color4f && right.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if mono.dataType == SGDataType.float && left.dataType == SGDataType.float && right.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if mono.dataType == SGDataType.int && left.dataType == SGDataType.int && right.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if mono.dataType == SGDataType.vector2f && left.dataType == SGDataType.vector2f && right.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if mono.dataType == SGDataType.vector3f && left.dataType == SGDataType.vector3f && right.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if mono.dataType == SGDataType.vector4f && left.dataType == SGDataType.vector4f && right.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_geometry_switch_cameraindex_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for geometrySwitchCameraindex"))
}
/// Geometric Property
public func geompropvalue<T>(geomprop: String = "", defaultValue: T) -> T where T: SGValue {
    let inputs: [SGNode.Input] = [
        .init(name: "geomprop", connection: SGString(source: .constant(.string(geomprop)))),
        .init(name: "default", connection: defaultValue),
    ]
    if defaultValue.dataType == SGDataType.bool {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_boolean",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.bool)])))
    }
    if defaultValue.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if defaultValue.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if defaultValue.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if defaultValue.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if defaultValue.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_integer",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.int)])))
    }
    if defaultValue.dataType == SGDataType.string {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_string",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.string)])))
    }
    if defaultValue.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if defaultValue.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if defaultValue.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_geompropvalue_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for geompropvalue"))
}
public func heighttonormal(_ in1: SGScalar = SGScalar(source: .constant(.float(0.0))), scale: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGVector {
    guard in1.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid heighttonormal input. Expected in data type to be SGDataType.float, but got \(in1.dataType)."))
    }
    guard scale.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid heighttonormal input. Expected scale data type to be SGDataType.float, but got \(scale.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "scale", connection: scale),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_heighttonormal_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// HSV Adjust
public func hsvadjust(_ in1: SGColor, amount: SGVector = SGVector(source: .constant(.vector3f([0, 1, 1])))) -> SGColor {
    guard amount.dataType == SGDataType.vector3f else {
        return SGColor(source: .error("Invalid hsvadjust input. Expected amount data type to be SGDataType.vector3f, but got \(amount.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "amount", connection: amount),
    ]
    if in1.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvadjust_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types for hsvadjust"))
}
/// HSV to RGB
public func hsvtorgb(_ in1: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_hsvtorgb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types for hsvtorgb"))
}
/// If Equal
public func ifEqual<T>(value1: SGValue = SGValue(source: .constant(.float(0.0))), value2: SGValue = SGValue(source: .constant(.float(0.0))), trueResult: T, falseResult: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: trueResult),
        .init(name: "in2", connection: falseResult),
    ]
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatB",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.half && value2.dataType == SGDataType.half && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfB",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.bool && value2.dataType == SGDataType.bool && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4B",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifequal_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ifEqual"))
}
/// If Greater
public func ifGreater<T>(value1: SGScalar = SGScalar(source: .constant(.float(1.0))), value2: SGScalar = SGScalar(source: .constant(.float(0.0))), trueResult: T, falseResult: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: trueResult),
        .init(name: "in2", connection: falseResult),
    ]
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.half && value2.dataType == SGDataType.half && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreater_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ifGreater"))
}
/// If Greater Or Equal
public func ifGreaterOrEqual<T>(value1: SGScalar = SGScalar(source: .constant(.float(1.0))), value2: SGScalar = SGScalar(source: .constant(.float(0.0))), trueResult: T, falseResult: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "value1", connection: value1),
        .init(name: "value2", connection: value2),
        .init(name: "in1", connection: trueResult),
        .init(name: "in2", connection: falseResult),
    ]
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.color3f && falseResult.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.color4f && falseResult.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.float && falseResult.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if value1.dataType == SGDataType.half && value2.dataType == SGDataType.half && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector2h && falseResult.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector3h && falseResult.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector4h && falseResult.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_half4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.half && falseResult.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector2f && falseResult.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector3f && falseResult.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if value1.dataType == SGDataType.float && value2.dataType == SGDataType.float && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if value1.dataType == SGDataType.int && value2.dataType == SGDataType.int && trueResult.dataType == SGDataType.vector4f && falseResult.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ifgreatereq_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ifGreaterOrEqual"))
}
/// Image
public func image<T>(file: SGTexture, defaultValue: T, texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), uaddressmode: SGAddressMode = SGAddressMode.periodic, vaddressmode: SGAddressMode = SGAddressMode.periodic, filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
    guard file.dataType == SGDataType.asset else {
        return T(source: .error("Invalid image input. Expected file data type to be SGDataType.asset, but got \(file.dataType)."))
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid image input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: defaultValue),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "uaddressmode", connection: SGString(source: .constant(.string(uaddressmode.rawValue)))),
        .init(name: "vaddressmode", connection: SGString(source: .constant(.string(vaddressmode.rawValue)))),
        .init(name: "filtertype", connection: SGString(source: .constant(.string(filtertype.rawValue)))),
    ]
    if defaultValue.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if defaultValue.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if defaultValue.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if defaultValue.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if defaultValue.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if defaultValue.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if defaultValue.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_image_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for image"))
}
/// Inside
public func inside<T>(_ in1: T, mask: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "mask", connection: mask),
    ]
    if in1.dataType == SGDataType.color3f && mask.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && mask.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && mask.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && mask.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_inside_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for inside"))
}
/// Invert Matrix
public func invertmatrix(_ in1: SGMatrix) -> SGMatrix {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.matrix2d {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix3d {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix4d {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_invertmatrix_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    return SGMatrix(source: .error("Unsupported input data types for invertmatrix"))
}
/// Magnitude
public func length(_ in1: SGVector) -> SGScalar {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.vector2h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_magnitude_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    return SGScalar(source: .error("Unsupported input data types for length"))
}
/// Natural Log
public func ln<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ln_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ln"))
}
/// And
public func logicalAnd(_ in1: SGValue = SGValue(source: .constant(.bool(false))), _ in2: SGValue = SGValue(source: .constant(.bool(false)))) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalAnd input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType)."))
    }
    guard in2.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalAnd input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_and",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// Not
public func logicalNot(_ in1: SGValue = SGValue(source: .constant(.bool(false)))) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalNot input. Expected in data type to be SGDataType.bool, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_not",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// Or
public func logicalOr(_ in1: SGValue = SGValue(source: .constant(.bool(false))), _ in2: SGValue = SGValue(source: .constant(.bool(false)))) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalOr input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType)."))
    }
    guard in2.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalOr input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_or",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// XOR
public func logicalXor(_ in1: SGValue = SGValue(source: .constant(.bool(false))), _ in2: SGValue = SGValue(source: .constant(.bool(false)))) -> SGValue {
    guard in1.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalXor input. Expected in1 data type to be SGDataType.bool, but got \(in1.dataType)."))
    }
    guard in2.dataType == SGDataType.bool else {
        return SGValue(source: .error("Invalid logicalXor input. Expected in2 data type to be SGDataType.bool, but got \(in2.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    return SGValue(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_logical_xor",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.bool)])))
}
/// Luminance
public func luminance(_ in1: SGColor, lumacoeffs: SGColor = SGColor(source: .constant(.color3f([0.2722287, 0.6740818, 0.0536895])))) -> SGColor {
    guard lumacoeffs.dataType == SGDataType.color3f else {
        return SGColor(source: .error("Invalid luminance input. Expected lumacoeffs data type to be SGDataType.color3f, but got \(lumacoeffs.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "lumacoeffs", connection: lumacoeffs),
    ]
    if in1.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_luminance_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types for luminance"))
}
public func mask(fg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), bg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid mask input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType)."))
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid mask input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType)."))
    }
    guard mix.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid mask input. Expected mix data type to be SGDataType.float, but got \(mix.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_mask_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
public func matte(fg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), bg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid matte input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType)."))
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid matte input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType)."))
    }
    guard mix.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid matte input. Expected mix data type to be SGDataType.float, but got \(mix.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_matte_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Max
public func max<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_max_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for max"))
}
/// Min
public func min<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_min_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for min"))
}
/// Subtractive Mix
public func minus<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_minus_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for minus"))
}
/// Mix
public func mix<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(0.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if fg.dataType == SGDataType.vector2h && bg.dataType == SGDataType.vector2h && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if fg.dataType == SGDataType.vector3h && bg.dataType == SGDataType.vector3h && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if fg.dataType == SGDataType.vector4h && bg.dataType == SGDataType.vector4h && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if fg.dataType == SGDataType.vector2f && bg.dataType == SGDataType.vector2f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if fg.dataType == SGDataType.vector3f && bg.dataType == SGDataType.vector3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if fg.dataType == SGDataType.vector4f && bg.dataType == SGDataType.vector4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_mix_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for mix"))
}
public func mixColor(fg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), bg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid mixColor input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType)."))
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid mixColor input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType)."))
    }
    guard mix.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid mixColor input. Expected mix data type to be SGDataType.float, but got \(mix.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_in_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Modulo
public func modulo<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_modulo_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for modulo"))
}
/// Multiply
public func multiply<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix2d && in2.dataType == SGDataType.matrix2d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix3d && in2.dataType == SGDataType.matrix3d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix4d && in2.dataType == SGDataType.matrix4d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_multiply_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for multiply"))
}
/// Noise 2D
public func noise2D(amplitude: SGNumeric, pivot: SGScalar = SGScalar(source: .constant(.float(0.0))), texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> SGNumeric {
    guard pivot.dataType == SGDataType.float else {
        return SGNumeric(source: .error("Invalid noise2D input. Expected pivot data type to be SGDataType.float, but got \(pivot.dataType)."))
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGNumeric(source: .error("Invalid noise2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "pivot", connection: pivot),
        .init(name: "texcoord", connection: texcoord),
    ]
    if amplitude.dataType == SGDataType.vector3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if amplitude.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise2d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGNumeric(source: .error("Unsupported input data types for noise2D"))
}
/// Noise 3D
public func noise3D(amplitude: SGNumeric, pivot: SGScalar = SGScalar(source: .constant(.float(0.0))), position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0])))) -> SGNumeric {
    guard pivot.dataType == SGDataType.float else {
        return SGNumeric(source: .error("Invalid noise3D input. Expected pivot data type to be SGDataType.float, but got \(pivot.dataType)."))
    }
    guard position.dataType == SGDataType.vector3f else {
        return SGNumeric(source: .error("Invalid noise3D input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "amplitude", connection: amplitude),
        .init(name: "pivot", connection: pivot),
        .init(name: "position", connection: position),
    ]
    if amplitude.dataType == SGDataType.vector3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGScalar(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if amplitude.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if amplitude.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if amplitude.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if amplitude.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_noise3d_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGNumeric(source: .error("Unsupported input data types for noise3D"))
}
public func normalMapDecode(_ in1: SGVector = SGVector(source: .constant(.vector3f([0.5, 0.5, 1])))) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid normalMapDecode input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_normal_map_decode",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Normalize
public func normalize(_ in1: SGVector) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.vector2h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalize_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGVector(source: .error("Unsupported input data types for normalize"))
}
public func normalmap(_ in1: SGVector = SGVector(source: .constant(.vector3f([0.5, 0.5, 1]))), space: SGNormalSpace = SGNormalSpace.tangent, scale: SGNumeric, normal: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), tangent: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0])))) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid normalmap input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid normalmap input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType)."))
    }
    guard tangent.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid normalmap input. Expected tangent data type to be SGDataType.vector3f, but got \(tangent.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "space", connection: SGString(source: .constant(.string(space.rawValue)))),
        .init(name: "scale", connection: scale),
        .init(name: "normal", connection: normal),
        .init(name: "tangent", connection: tangent),
    ]
    if scale.dataType == SGDataType.float {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if scale.dataType == SGDataType.vector2f {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_normalmap_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    return SGVector(source: .error("Unsupported input data types for normalmap"))
}
/// One Minus
public func oneMinus<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_oneminus_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for oneMinus"))
}
public func out(fg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), bg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid out input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType)."))
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid out input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType)."))
    }
    guard mix.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid out input. Expected mix data type to be SGDataType.float, but got \(mix.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_out_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Outside
public func outside<T>(_ in1: T, mask: SGScalar = SGScalar(source: .constant(.float(0.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "mask", connection: mask),
    ]
    if in1.dataType == SGDataType.color3f && mask.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && mask.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && mask.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && mask.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_outside_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for outside"))
}
public func over(fg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), bg: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 0]))), mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGColor {
    guard fg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid over input. Expected fg data type to be SGDataType.color4f, but got \(fg.dataType)."))
    }
    guard bg.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid over input. Expected bg data type to be SGDataType.color4f, but got \(bg.dataType)."))
    }
    guard mix.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid over input. Expected mix data type to be SGDataType.float, but got \(mix.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_over_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Overlay
public func overlay<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_overlay_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for overlay"))
}
public func place2D(texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), pivot: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), scale: SGVector = SGVector(source: .constant(.vector2f([1, 1]))), rotate: SGScalar = SGScalar(source: .constant(.float(0.0))), offset: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> SGVector {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid place2D input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    guard pivot.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid place2D input. Expected pivot data type to be SGDataType.vector2f, but got \(pivot.dataType)."))
    }
    guard scale.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid place2D input. Expected scale data type to be SGDataType.vector2f, but got \(scale.dataType)."))
    }
    guard rotate.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid place2D input. Expected rotate data type to be SGDataType.float, but got \(rotate.dataType)."))
    }
    guard offset.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid place2D input. Expected offset data type to be SGDataType.vector2f, but got \(offset.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "pivot", connection: pivot),
        .init(name: "scale", connection: scale),
        .init(name: "rotate", connection: rotate),
        .init(name: "offset", connection: offset),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_place2d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Additive Mix
public func plus<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_plus_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for plus"))
}
/// Power
public func pow<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_power_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for pow"))
}
public func premult(_ in1: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 1])))) -> SGColor {
    guard in1.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid premult input. Expected in data type to be SGDataType.color4f, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_premult_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Ramp 4 Corners
public func ramp4<T>(valuetl: T, valuetr: T, valuebl: T, valuebr: T, texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> T where T: SGNumeric {
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid ramp4 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuetl", connection: valuetl),
        .init(name: "valuetr", connection: valuetr),
        .init(name: "valuebl", connection: valuebl),
        .init(name: "valuebr", connection: valuebr),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuetl.dataType == SGDataType.color3f && valuetr.dataType == SGDataType.color3f && valuebl.dataType == SGDataType.color3f && valuebr.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuetl.dataType == SGDataType.color4f && valuetr.dataType == SGDataType.color4f && valuebl.dataType == SGDataType.color4f && valuebr.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuetl.dataType == SGDataType.float && valuetr.dataType == SGDataType.float && valuebl.dataType == SGDataType.float && valuebr.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuetl.dataType == SGDataType.vector2f && valuetr.dataType == SGDataType.vector2f && valuebl.dataType == SGDataType.vector2f && valuebr.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuetl.dataType == SGDataType.vector3f && valuetr.dataType == SGDataType.vector3f && valuebl.dataType == SGDataType.vector3f && valuebr.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuetl.dataType == SGDataType.vector4f && valuetr.dataType == SGDataType.vector4f && valuebl.dataType == SGDataType.vector4f && valuebr.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramp4_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ramp4"))
}
/// Ramp Horizontal
public func ramplr<T>(valuel: T, valuer: T, texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> T where T: SGNumeric {
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid ramplr input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuel", connection: valuel),
        .init(name: "valuer", connection: valuer),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuel.dataType == SGDataType.color3f && valuer.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuel.dataType == SGDataType.color4f && valuer.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuel.dataType == SGDataType.float && valuer.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuel.dataType == SGDataType.half && valuer.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuel.dataType == SGDataType.vector2h && valuer.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if valuel.dataType == SGDataType.vector3h && valuer.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if valuel.dataType == SGDataType.vector4h && valuer.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if valuel.dataType == SGDataType.vector2f && valuer.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuel.dataType == SGDataType.vector3f && valuer.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuel.dataType == SGDataType.vector4f && valuer.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramplr_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ramplr"))
}
/// Ramp Vertical
public func ramptb<T>(valuet: T, valueb: T, texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> T where T: SGNumeric {
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid ramptb input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuet", connection: valuet),
        .init(name: "valueb", connection: valueb),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuet.dataType == SGDataType.color3f && valueb.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuet.dataType == SGDataType.color4f && valueb.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuet.dataType == SGDataType.float && valueb.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuet.dataType == SGDataType.half && valueb.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuet.dataType == SGDataType.vector2h && valueb.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if valuet.dataType == SGDataType.vector3h && valueb.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if valuet.dataType == SGDataType.vector4h && valueb.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if valuet.dataType == SGDataType.vector2f && valueb.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuet.dataType == SGDataType.vector3f && valueb.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuet.dataType == SGDataType.vector4f && valueb.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_ramptb_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for ramptb"))
}
/// Range
public func range<T>(_ in1: T, inlow: SGNumeric, inhigh: SGNumeric, gamma: SGNumeric, outlow: SGNumeric, outhigh: SGNumeric, doclamp: SGValue = SGValue(source: .constant(.bool(false)))) -> T where T: SGNumeric {
    guard doclamp.dataType == SGDataType.bool else {
        return T(source: .error("Invalid range input. Expected doclamp data type to be SGDataType.bool, but got \(doclamp.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "inlow", connection: inlow),
        .init(name: "inhigh", connection: inhigh),
        .init(name: "gamma", connection: gamma),
        .init(name: "outlow", connection: outlow),
        .init(name: "outhigh", connection: outhigh),
        .init(name: "doclamp", connection: doclamp),
    ]
    if in1.dataType == SGDataType.color3f && inlow.dataType == SGDataType.color3f && inhigh.dataType == SGDataType.color3f && gamma.dataType == SGDataType.color3f && outlow.dataType == SGDataType.color3f && outhigh.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && inlow.dataType == SGDataType.color4f && inhigh.dataType == SGDataType.color4f && gamma.dataType == SGDataType.color4f && outlow.dataType == SGDataType.color4f && outhigh.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.vector2f && inhigh.dataType == SGDataType.vector2f && gamma.dataType == SGDataType.vector2f && outlow.dataType == SGDataType.vector2f && outhigh.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.vector3f && inhigh.dataType == SGDataType.vector3f && gamma.dataType == SGDataType.vector3f && outlow.dataType == SGDataType.vector3f && outhigh.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.vector4f && inhigh.dataType == SGDataType.vector4f && gamma.dataType == SGDataType.vector4f && outlow.dataType == SGDataType.vector4f && outhigh.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && gamma.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_range_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for range"))
}
/// Reflect
public func reflect(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), normal: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0])))) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid reflect input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid reflect input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "normal", connection: normal),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_reflect_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Refract
public func refract(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), normal: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), eta: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid refract input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    guard normal.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid refract input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType)."))
    }
    guard eta.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid refract input. Expected eta data type to be SGDataType.float, but got \(eta.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "normal", connection: normal),
        .init(name: "eta", connection: eta),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_realitykit_refract_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Remap
public func remap<T>(_ in1: T, inlow: SGNumeric, inhigh: SGNumeric, outlow: SGNumeric, outhigh: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "inlow", connection: inlow),
        .init(name: "inhigh", connection: inhigh),
        .init(name: "outlow", connection: outlow),
        .init(name: "outhigh", connection: outhigh),
    ]
    if in1.dataType == SGDataType.color3f && inlow.dataType == SGDataType.color3f && inhigh.dataType == SGDataType.color3f && outlow.dataType == SGDataType.color3f && outhigh.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && inlow.dataType == SGDataType.color4f && inhigh.dataType == SGDataType.color4f && outlow.dataType == SGDataType.color4f && outhigh.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && inlow.dataType == SGDataType.half && inhigh.dataType == SGDataType.half && outlow.dataType == SGDataType.half && outhigh.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && inlow.dataType == SGDataType.vector2h && inhigh.dataType == SGDataType.vector2h && outlow.dataType == SGDataType.vector2h && outhigh.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && inlow.dataType == SGDataType.vector3h && inhigh.dataType == SGDataType.vector3h && outlow.dataType == SGDataType.vector3h && outhigh.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && inlow.dataType == SGDataType.vector4h && inhigh.dataType == SGDataType.vector4h && outlow.dataType == SGDataType.vector4h && outhigh.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.vector2f && inhigh.dataType == SGDataType.vector2f && outlow.dataType == SGDataType.vector2f && outhigh.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.vector3f && inhigh.dataType == SGDataType.vector3f && outlow.dataType == SGDataType.vector3f && outhigh.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.vector4f && inhigh.dataType == SGDataType.vector4f && outlow.dataType == SGDataType.vector4f && outhigh.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && inlow.dataType == SGDataType.float && inhigh.dataType == SGDataType.float && outlow.dataType == SGDataType.float && outhigh.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_remap_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for remap"))
}
/// RGB to HSV
public func rgbtohsv(_ in1: SGColor) -> SGColor {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_rgbtohsv_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types for rgbtohsv"))
}
public func rotate2D(_ in1: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), amount: SGScalar = SGScalar(source: .constant(.float(0.0)))) -> SGVector {
    guard in1.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid rotate2D input. Expected in data type to be SGDataType.vector2f, but got \(in1.dataType)."))
    }
    guard amount.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid rotate2D input. Expected amount data type to be SGDataType.float, but got \(amount.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "amount", connection: amount),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_rotate2d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
public func rotate3D(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), amount: SGScalar = SGScalar(source: .constant(.float(0.0))), axis: SGVector = SGVector(source: .constant(.vector3f([0, 1, 0])))) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid rotate3D input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    guard amount.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid rotate3D input. Expected amount data type to be SGDataType.float, but got \(amount.dataType)."))
    }
    guard axis.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid rotate3D input. Expected axis data type to be SGDataType.vector3f, but got \(axis.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "amount", connection: amount),
        .init(name: "axis", connection: axis),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_rotate3d_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Round
public func round<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_round_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for round"))
}
/// Safe Power
public func safePow<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_safepower_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for safePow"))
}
/// Saturate
public func saturate(_ in1: SGColor, amount: SGScalar = SGScalar(source: .constant(.float(1.0))), lumacoeffs: SGColor = SGColor(source: .constant(.color3f([0.2722287, 0.6740818, 0.0536895])))) -> SGColor {
    guard amount.dataType == SGDataType.float else {
        return SGColor(source: .error("Invalid saturate input. Expected amount data type to be SGDataType.float, but got \(amount.dataType)."))
    }
    guard lumacoeffs.dataType == SGDataType.color3f else {
        return SGColor(source: .error("Invalid saturate input. Expected lumacoeffs data type to be SGDataType.color3f, but got \(lumacoeffs.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "amount", connection: amount),
        .init(name: "lumacoeffs", connection: lumacoeffs),
    ]
    if in1.dataType == SGDataType.color3f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return SGColor(source: .nodeOutput(SGNode(
            nodeType: "ND_saturate_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    return SGColor(source: .error("Unsupported input data types for saturate"))
}
/// Screen
public func screen<T>(fg: T, bg: T, mix: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "fg", connection: fg),
        .init(name: "bg", connection: bg),
        .init(name: "mix", connection: mix),
    ]
    if fg.dataType == SGDataType.color3f && bg.dataType == SGDataType.color3f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if fg.dataType == SGDataType.color4f && bg.dataType == SGDataType.color4f && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if fg.dataType == SGDataType.float && bg.dataType == SGDataType.float && mix.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if fg.dataType == SGDataType.half && bg.dataType == SGDataType.half && mix.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_screen_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    return T(source: .error("Unsupported input data types for screen"))
}
/// Sign
public func sign<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sign_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for sign"))
}
/// Sin
public func sin<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sin_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for sin"))
}
/// Smooth Step
public func smoothstep<T>(_ in1: T, low: SGNumeric, high: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "low", connection: low),
        .init(name: "high", connection: high),
    ]
    if in1.dataType == SGDataType.color3f && low.dataType == SGDataType.color3f && high.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && low.dataType == SGDataType.color4f && high.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && low.dataType == SGDataType.half && high.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h && low.dataType == SGDataType.vector2h && high.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector2h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h && low.dataType == SGDataType.vector3h && high.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector3h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h && low.dataType == SGDataType.vector4h && high.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector4h && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_half4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f && low.dataType == SGDataType.vector2f && high.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && low.dataType == SGDataType.vector3f && high.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && low.dataType == SGDataType.vector4f && high.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && low.dataType == SGDataType.float && high.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_smoothstep_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for smoothstep"))
}
/// Split Horizontal
public func splitlr<T>(valuel: T, valuer: T, center: SGScalar = SGScalar(source: .constant(.float(0.5))), texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> T where T: SGNumeric {
    guard center.dataType == SGDataType.float else {
        return T(source: .error("Invalid splitlr input. Expected center data type to be SGDataType.float, but got \(center.dataType)."))
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid splitlr input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuel", connection: valuel),
        .init(name: "valuer", connection: valuer),
        .init(name: "center", connection: center),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuel.dataType == SGDataType.color3f && valuer.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuel.dataType == SGDataType.color4f && valuer.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuel.dataType == SGDataType.float && valuer.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuel.dataType == SGDataType.half && valuer.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuel.dataType == SGDataType.vector2f && valuer.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuel.dataType == SGDataType.vector3f && valuer.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuel.dataType == SGDataType.vector4f && valuer.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splitlr_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for splitlr"))
}
/// Split Vertical
public func splittb<T>(valuet: T, valueb: T, center: SGScalar = SGScalar(source: .constant(.float(0.5))), texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0])))) -> T where T: SGNumeric {
    guard center.dataType == SGDataType.float else {
        return T(source: .error("Invalid splittb input. Expected center data type to be SGDataType.float, but got \(center.dataType)."))
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid splittb input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "valuet", connection: valuet),
        .init(name: "valueb", connection: valueb),
        .init(name: "center", connection: center),
        .init(name: "texcoord", connection: texcoord),
    ]
    if valuet.dataType == SGDataType.color3f && valueb.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if valuet.dataType == SGDataType.color4f && valueb.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if valuet.dataType == SGDataType.float && valueb.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if valuet.dataType == SGDataType.half && valueb.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if valuet.dataType == SGDataType.vector2h && valueb.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if valuet.dataType == SGDataType.vector3h && valueb.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if valuet.dataType == SGDataType.vector4h && valueb.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if valuet.dataType == SGDataType.vector2f && valueb.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if valuet.dataType == SGDataType.vector3f && valueb.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if valuet.dataType == SGDataType.vector4f && valueb.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_splittb_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for splittb"))
}
/// Square Root
public func sqrt<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_sqrt_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for sqrt"))
}
/// Step
public func step<T>(_ in1: T, edge: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "edge", connection: edge),
    ]
    if in1.dataType == SGDataType.color3f && edge.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && edge.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && edge.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.vector2f && edge.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && edge.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && edge.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_realitykit_step_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for step"))
}
/// Subtract
public func subtract<T>(_ in1: T, _ in2: SGNumeric) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_color4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.matrix2d && in2.dataType == SGDataType.matrix2d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix2d && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix22FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix3d && in2.dataType == SGDataType.matrix3d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix3d && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix33FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix4d && in2.dataType == SGDataType.matrix4d {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if in1.dataType == SGDataType.matrix4d && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_matrix44FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector2FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector3FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_subtract_vector4FA",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for subtract"))
}
/// Switch
public func switchValue<T>(_ in1: T, _ in2: T, _ in3: T, _ in4: T, _ in5: T, _ in6: T, _ in7: T, _ in8: T, _ in9: T, _ in10: T, which: SGScalar = SGScalar(source: .constant(.float(0.0)))) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in1", connection: in1),
        .init(name: "in2", connection: in2),
        .init(name: "in3", connection: in3),
        .init(name: "in4", connection: in4),
        .init(name: "in5", connection: in5),
        .init(name: "in6", connection: in6),
        .init(name: "in7", connection: in7),
        .init(name: "in8", connection: in8),
        .init(name: "in9", connection: in9),
        .init(name: "in10", connection: in10),
        .init(name: "which", connection: which),
    ]
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f && in3.dataType == SGDataType.color3f && in4.dataType == SGDataType.color3f && in5.dataType == SGDataType.color3f && in6.dataType == SGDataType.color3f && in7.dataType == SGDataType.color3f && in8.dataType == SGDataType.color3f && in9.dataType == SGDataType.color3f && in10.dataType == SGDataType.color3f && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color3f && in2.dataType == SGDataType.color3f && in3.dataType == SGDataType.color3f && in4.dataType == SGDataType.color3f && in5.dataType == SGDataType.color3f && in6.dataType == SGDataType.color3f && in7.dataType == SGDataType.color3f && in8.dataType == SGDataType.color3f && in9.dataType == SGDataType.color3f && in10.dataType == SGDataType.color3f && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f && in3.dataType == SGDataType.color4f && in4.dataType == SGDataType.color4f && in5.dataType == SGDataType.color4f && in6.dataType == SGDataType.color4f && in7.dataType == SGDataType.color4f && in8.dataType == SGDataType.color4f && in9.dataType == SGDataType.color4f && in10.dataType == SGDataType.color4f && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.color4f && in2.dataType == SGDataType.color4f && in3.dataType == SGDataType.color4f && in4.dataType == SGDataType.color4f && in5.dataType == SGDataType.color4f && in6.dataType == SGDataType.color4f && in7.dataType == SGDataType.color4f && in8.dataType == SGDataType.color4f && in9.dataType == SGDataType.color4f && in10.dataType == SGDataType.color4f && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_color4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float && in3.dataType == SGDataType.float && in4.dataType == SGDataType.float && in5.dataType == SGDataType.float && in6.dataType == SGDataType.float && in7.dataType == SGDataType.float && in8.dataType == SGDataType.float && in9.dataType == SGDataType.float && in10.dataType == SGDataType.float && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.float && in2.dataType == SGDataType.float && in3.dataType == SGDataType.float && in4.dataType == SGDataType.float && in5.dataType == SGDataType.float && in6.dataType == SGDataType.float && in7.dataType == SGDataType.float && in8.dataType == SGDataType.float && in9.dataType == SGDataType.float && in10.dataType == SGDataType.float && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_floatI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half && in3.dataType == SGDataType.half && in4.dataType == SGDataType.half && in5.dataType == SGDataType.half && in6.dataType == SGDataType.half && in7.dataType == SGDataType.half && in8.dataType == SGDataType.half && in9.dataType == SGDataType.half && in10.dataType == SGDataType.half && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.half && in2.dataType == SGDataType.half && in3.dataType == SGDataType.half && in4.dataType == SGDataType.half && in5.dataType == SGDataType.half && in6.dataType == SGDataType.half && in7.dataType == SGDataType.half && in8.dataType == SGDataType.half && in9.dataType == SGDataType.half && in10.dataType == SGDataType.half && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_halfI",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f && in3.dataType == SGDataType.vector2f && in4.dataType == SGDataType.vector2f && in5.dataType == SGDataType.vector2f && in6.dataType == SGDataType.vector2f && in7.dataType == SGDataType.vector2f && in8.dataType == SGDataType.vector2f && in9.dataType == SGDataType.vector2f && in10.dataType == SGDataType.vector2f && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector2f && in2.dataType == SGDataType.vector2f && in3.dataType == SGDataType.vector2f && in4.dataType == SGDataType.vector2f && in5.dataType == SGDataType.vector2f && in6.dataType == SGDataType.vector2f && in7.dataType == SGDataType.vector2f && in8.dataType == SGDataType.vector2f && in9.dataType == SGDataType.vector2f && in10.dataType == SGDataType.vector2f && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector2I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f && in3.dataType == SGDataType.vector3f && in4.dataType == SGDataType.vector3f && in5.dataType == SGDataType.vector3f && in6.dataType == SGDataType.vector3f && in7.dataType == SGDataType.vector3f && in8.dataType == SGDataType.vector3f && in9.dataType == SGDataType.vector3f && in10.dataType == SGDataType.vector3f && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector3f && in2.dataType == SGDataType.vector3f && in3.dataType == SGDataType.vector3f && in4.dataType == SGDataType.vector3f && in5.dataType == SGDataType.vector3f && in6.dataType == SGDataType.vector3f && in7.dataType == SGDataType.vector3f && in8.dataType == SGDataType.vector3f && in9.dataType == SGDataType.vector3f && in10.dataType == SGDataType.vector3f && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector3I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f && in3.dataType == SGDataType.vector4f && in4.dataType == SGDataType.vector4f && in5.dataType == SGDataType.vector4f && in6.dataType == SGDataType.vector4f && in7.dataType == SGDataType.vector4f && in8.dataType == SGDataType.vector4f && in9.dataType == SGDataType.vector4f && in10.dataType == SGDataType.vector4f && which.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    if in1.dataType == SGDataType.vector4f && in2.dataType == SGDataType.vector4f && in3.dataType == SGDataType.vector4f && in4.dataType == SGDataType.vector4f && in5.dataType == SGDataType.vector4f && in6.dataType == SGDataType.vector4f && in7.dataType == SGDataType.vector4f && in8.dataType == SGDataType.vector4f && in9.dataType == SGDataType.vector4f && in10.dataType == SGDataType.vector4f && which.dataType == SGDataType.int {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_switch_vector4I",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for switchValue"))
}
/// Tan
public func tan<T>(_ in1: T) -> T where T: SGNumeric {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if in1.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if in1.dataType == SGDataType.vector2h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2h)])))
    }
    if in1.dataType == SGDataType.vector3h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3h)])))
    }
    if in1.dataType == SGDataType.vector4h {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_half4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4h)])))
    }
    if in1.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tan_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for tan"))
}
/// Tiled Image
public func tiledimage<T>(file: SGTexture, defaultValue: T, texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), uvtiling: SGVector = SGVector(source: .constant(.vector2f([1, 1]))), uvoffset: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), realworldimagesize: SGVector = SGVector(source: .constant(.vector2f([1, 1]))), realworldtilesize: SGVector = SGVector(source: .constant(.vector2f([1, 1]))), filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
    guard file.dataType == SGDataType.asset else {
        return T(source: .error("Invalid tiledimage input. Expected file data type to be SGDataType.asset, but got \(file.dataType)."))
    }
    guard texcoord.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid tiledimage input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    guard uvtiling.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid tiledimage input. Expected uvtiling data type to be SGDataType.vector2f, but got \(uvtiling.dataType)."))
    }
    guard uvoffset.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid tiledimage input. Expected uvoffset data type to be SGDataType.vector2f, but got \(uvoffset.dataType)."))
    }
    guard realworldimagesize.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid tiledimage input. Expected realworldimagesize data type to be SGDataType.vector2f, but got \(realworldimagesize.dataType)."))
    }
    guard realworldtilesize.dataType == SGDataType.vector2f else {
        return T(source: .error("Invalid tiledimage input. Expected realworldtilesize data type to be SGDataType.vector2f, but got \(realworldtilesize.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "file", connection: file),
        .init(name: "default", connection: defaultValue),
        .init(name: "texcoord", connection: texcoord),
        .init(name: "uvtiling", connection: uvtiling),
        .init(name: "uvoffset", connection: uvoffset),
        .init(name: "realworldimagesize", connection: realworldimagesize),
        .init(name: "realworldtilesize", connection: realworldtilesize),
        .init(name: "filtertype", connection: SGString(source: .constant(.string(filtertype.rawValue)))),
    ]
    if defaultValue.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if defaultValue.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if defaultValue.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if defaultValue.dataType == SGDataType.half {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_half",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.half)])))
    }
    if defaultValue.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if defaultValue.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if defaultValue.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_tiledimage_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for tiledimage"))
}
/// Transform Matrix
public func transformmatrix(_ in1: SGVector, mat: SGMatrix) -> SGVector {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "mat", connection: mat),
    ]
    if in1.dataType == SGDataType.vector2f && mat.dataType == SGDataType.matrix2d {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if in1.dataType == SGDataType.vector3f && mat.dataType == SGDataType.matrix3d {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if in1.dataType == SGDataType.vector4f && mat.dataType == SGDataType.matrix4d {
        return SGVector(source: .nodeOutput(SGNode(
            nodeType: "ND_transformmatrix_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return SGVector(source: .error("Unsupported input data types for transformmatrix"))
}
/// Transform Matrix
public func transformmatrixVector2m3(_ in1: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), mat: SGMatrix = SGMatrix(source: .constant(.matrix3d(simd_float3x3(columns: ( [1, 0, 0], [0, 1, 0], [0, 0, 1] )))))) -> SGVector {
    guard in1.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid transformmatrixVector2m3 input. Expected in data type to be SGDataType.vector2f, but got \(in1.dataType)."))
    }
    guard mat.dataType == SGDataType.matrix3d else {
        return SGVector(source: .error("Invalid transformmatrixVector2m3 input. Expected mat data type to be SGDataType.matrix3d, but got \(mat.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "mat", connection: mat),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformmatrix_vector2M3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Transform Matrix
public func transformmatrixVector3m4(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), mat: SGMatrix = SGMatrix(source: .constant(.matrix4d(simd_float4x4(columns: ( [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] )))))) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid transformmatrixVector3m4 input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    guard mat.dataType == SGDataType.matrix4d else {
        return SGVector(source: .error("Invalid transformmatrixVector3m4 input. Expected mat data type to be SGDataType.matrix4d, but got \(mat.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "mat", connection: mat),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformmatrix_vector3M4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transformnormal(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 1]))), fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid transformnormal input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "fromspace", connection: SGString(source: .constant(.string(fromspace.rawValue)))),
        .init(name: "tospace", connection: SGString(source: .constant(.string(tospace.rawValue)))),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformnormal_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transformpoint(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid transformpoint input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "fromspace", connection: SGString(source: .constant(.string(fromspace.rawValue)))),
        .init(name: "tospace", connection: SGString(source: .constant(.string(tospace.rawValue)))),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformpoint_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
public func transformvector(_ in1: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), fromspace: SGTransformSpace, tospace: SGTransformSpace) -> SGVector {
    guard in1.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid transformvector input. Expected in data type to be SGDataType.vector3f, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
        .init(name: "fromspace", connection: SGString(source: .constant(.string(fromspace.rawValue)))),
        .init(name: "tospace", connection: SGString(source: .constant(.string(tospace.rawValue)))),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_transformvector_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Transpose
public func transpose(_ in1: SGMatrix) -> SGMatrix {
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    if in1.dataType == SGDataType.matrix2d {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix22",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix2d)])))
    }
    if in1.dataType == SGDataType.matrix3d {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix33",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix3d)])))
    }
    if in1.dataType == SGDataType.matrix4d {
        return SGMatrix(source: .nodeOutput(SGNode(
            nodeType: "ND_transpose_matrix44",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.matrix4d)])))
    }
    return SGMatrix(source: .error("Unsupported input data types for transpose"))
}
/// Triplanar Projection
public func triplanarprojection<T>(filex: SGTexture, filey: SGTexture, filez: SGTexture, defaultValue: T, position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), normal: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), filtertype: SGFilterType = SGFilterType.linear) -> T where T: SGNumeric {
    guard filex.dataType == SGDataType.asset else {
        return T(source: .error("Invalid triplanarprojection input. Expected filex data type to be SGDataType.asset, but got \(filex.dataType)."))
    }
    guard filey.dataType == SGDataType.asset else {
        return T(source: .error("Invalid triplanarprojection input. Expected filey data type to be SGDataType.asset, but got \(filey.dataType)."))
    }
    guard filez.dataType == SGDataType.asset else {
        return T(source: .error("Invalid triplanarprojection input. Expected filez data type to be SGDataType.asset, but got \(filez.dataType)."))
    }
    guard position.dataType == SGDataType.vector3f else {
        return T(source: .error("Invalid triplanarprojection input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    guard normal.dataType == SGDataType.vector3f else {
        return T(source: .error("Invalid triplanarprojection input. Expected normal data type to be SGDataType.vector3f, but got \(normal.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "filex", connection: filex),
        .init(name: "filey", connection: filey),
        .init(name: "filez", connection: filez),
        .init(name: "default", connection: defaultValue),
        .init(name: "position", connection: position),
        .init(name: "normal", connection: normal),
        .init(name: "filtertype", connection: SGString(source: .constant(.string(filtertype.rawValue)))),
    ]
    if defaultValue.dataType == SGDataType.color3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color3f)])))
    }
    if defaultValue.dataType == SGDataType.color4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_color4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.color4f)])))
    }
    if defaultValue.dataType == SGDataType.float {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_float",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.float)])))
    }
    if defaultValue.dataType == SGDataType.vector2f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector2",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector2f)])))
    }
    if defaultValue.dataType == SGDataType.vector3f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector3",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector3f)])))
    }
    if defaultValue.dataType == SGDataType.vector4f {
        return T(source: .nodeOutput(SGNode(
            nodeType: "ND_triplanarprojection_vector4",
            inputs: inputs,
            outputs: [.init(dataType: SGDataType.vector4f)])))
    }
    return T(source: .error("Unsupported input data types for triplanarprojection"))
}
public func unpremult(_ in1: SGColor = SGColor(source: .constant(.color4f([0, 0, 0, 1])))) -> SGColor {
    guard in1.dataType == SGDataType.color4f else {
        return SGColor(source: .error("Invalid unpremult input. Expected in data type to be SGDataType.color4f, but got \(in1.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "in", connection: in1),
    ]
    return SGColor(source: .nodeOutput(SGNode(
        nodeType: "ND_unpremult_color4",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.color4f)])))
}
/// Worley Noise 2D
public func worleynoise2DFloat(texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), jitter: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGScalar {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGScalar(source: .error("Invalid worleynoise2DFloat input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    guard jitter.dataType == SGDataType.float else {
        return SGScalar(source: .error("Invalid worleynoise2DFloat input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "jitter", connection: jitter),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Worley Noise 2D
public func worleynoise2DVector2(texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), jitter: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGVector {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid worleynoise2DVector2 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    guard jitter.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid worleynoise2DVector2 input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "jitter", connection: jitter),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Worley Noise 2D
public func worleynoise2DVector3(texcoord: SGVector = SGVector(source: .constant(.vector2f([0, 0]))), jitter: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGVector {
    guard texcoord.dataType == SGDataType.vector2f else {
        return SGVector(source: .error("Invalid worleynoise2DVector3 input. Expected texcoord data type to be SGDataType.vector2f, but got \(texcoord.dataType)."))
    }
    guard jitter.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid worleynoise2DVector3 input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "texcoord", connection: texcoord),
        .init(name: "jitter", connection: jitter),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise2d_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
/// Worley Noise 3D
public func worleynoise3DFloat(position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), jitter: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGScalar {
    guard position.dataType == SGDataType.vector3f else {
        return SGScalar(source: .error("Invalid worleynoise3DFloat input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    guard jitter.dataType == SGDataType.float else {
        return SGScalar(source: .error("Invalid worleynoise3DFloat input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
        .init(name: "jitter", connection: jitter),
    ]
    return SGScalar(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_float",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.float)])))
}
/// Worley Noise 3D
public func worleynoise3DVector2(position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), jitter: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGVector {
    guard position.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid worleynoise3DVector2 input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    guard jitter.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid worleynoise3DVector2 input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
        .init(name: "jitter", connection: jitter),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_vector2",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector2f)])))
}
/// Worley Noise 3D
public func worleynoise3DVector3(position: SGVector = SGVector(source: .constant(.vector3f([0, 0, 0]))), jitter: SGScalar = SGScalar(source: .constant(.float(1.0)))) -> SGVector {
    guard position.dataType == SGDataType.vector3f else {
        return SGVector(source: .error("Invalid worleynoise3DVector3 input. Expected position data type to be SGDataType.vector3f, but got \(position.dataType)."))
    }
    guard jitter.dataType == SGDataType.float else {
        return SGVector(source: .error("Invalid worleynoise3DVector3 input. Expected jitter data type to be SGDataType.float, but got \(jitter.dataType)."))
    }
    let inputs: [SGNode.Input] = [
        .init(name: "position", connection: position),
        .init(name: "jitter", connection: jitter),
    ]
    return SGVector(source: .nodeOutput(SGNode(
        nodeType: "ND_worleynoise3d_vector3",
        inputs: inputs,
        outputs: [.init(dataType: SGDataType.vector3f)])))
}
