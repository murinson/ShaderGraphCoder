import os
from typing import List, Union
from pxr import Usd

class Node():
    def __init__(self, prim):
        self.name = str(prim.GetName())
        property_names = prim.GetPropertyNames()
        self.inputs = []
        self.outputs = []
        for pn in property_names:
            p = prim.GetAttribute(pn)
            if pn.startswith('inputs:'):
                self.inputs.append(NodeProperty(self, pn, p))
            if pn.startswith('outputs:'):
                self.outputs.append(NodeProperty(self, pn, p))

    def __str__(self):
        return f'{self.name} ({len(self.inputs)} inputs, {len(self.outputs)} outputs)'
    
class NodeProperty():
    def __init__(self, node: Node, property_name: str, p):
        self.property_name = property_name
        self.name = property_name.split(':')[-1]
        t = p.GetTypeName()
        self.type_name = t.type.typeName
        self.type_is_array = t.isArray
        self.default_value = p.Get() if p.HasValue() else None

    def __str__(self):
        return f'{self.name}: {self.type_name} = {self.default_value}'

def is_node(prim):
    path = str(prim.GetPath()).split('/')
    return len(path) == 2 and len(path[0]) == 0 and path[1].startswith('ND_')

def should_output_node(node: Node):
    if node.name.startswith('ND_Internal'):
        print(f'Skipping {node.name} because it is internal')
        return False
    if len(node.outputs) != 1:
        print(f'Skipping {node.name} because it has {len(node.outputs)} outputs')
        return False
    if node.outputs[0].type_is_array:
        print(f'Skipping {node.name} because its output is an array')
        return False
    return True

suffix_type_names: List[str] = [
    "_boolean",
    "_color3",
    "_color3FA",
    "_color4",
    "_color4FA",
    "_half",
    "_half2",
    "_half2B",
    "_half2FA",
    "_half2I",
    "_half3",
    "_half3B",
    "_half3FA",
    "_half3I",
    "_half4",
    "_half4B",
    "_half4FA",
    "_half4I",
    "_integer",
    "_integer2",
    "_integer3",
    "_integer4",
    "_float",
    "_matrix22",
    "_matrix22FA",
    "_matrix33",
    "_matrix33FA",
    "_matrix44",
    "_matrix44FA",
    "_string",
    "_vector2",
    "_vector3",
    "_vector4",
    "_vector2FA",
    "_vector3FA",
    "_vector4FA",
]

def get_node_suffix_type_name(node: Node):
    for suffix in suffix_type_names:
        if node.name.endswith(suffix):
            return suffix
    return None

class SwiftWriter():
    def __init__(self):
        self.lines = []
        self.current_line = ""
        self.write_header()

    def commit_current_line(self):
        if len(self.current_line) > 0:
            self.lines.append(self.current_line)
            self.current_line = ""

    def output_to_file(self, file_path: str):
        with open(file_path, 'w') as f:
            self.write_footer(f)
            for line in self.lines:
                f.write(line)
                f.write('\n')

    def write_header(self):
        self.write_line('// Autogenerated by opgen.py')
        self.write_line('import Foundation')
        self.write_line('')

    def write_footer(self, f):
        self.write_line('')

    def write_line(self, text: str):
        self.current_line += text
        self.commit_current_line()

    def write(self, text: str):
        self.current_line += text

def write_node(node: Node, w: SwiftWriter):
    suffix_type_name = get_node_suffix_type_name(node)
    base_name = node.name[:-len(suffix_type_name)] if suffix_type_name else node.name
    swift_name = base_name
    w.write(f'public func {swift_name}(')
    for i, input in enumerate(node.inputs):
        w.write(f'{input.name}: {input.type_name}')
        if i < len(node.inputs) - 1:
            w.write(', ')
    w.write(') -> ')
    output = node.outputs[0]
    w.write(f'{output.type_name}')
    w.write_line(' {')
    w.write_line('}')

tools_path = os.path.dirname(os.path.abspath(__file__))
schemas_path = os.path.join(tools_path, 'schemas.usda')
src_path = os.path.abspath(os.path.join(tools_path, '..', 'Sources', 'ShaderGraphCoder'))

ops_out_path = os.path.join(src_path, 'Operations.g.swift')

stage = Usd.Stage.Open(schemas_path)
all_prims = [x for x in stage.Traverse()]  
nodes = [Node(x) for x in all_prims if is_node(x)]
print(f'Found {len(nodes)} nodes')
output_nodes = [x for x in nodes if should_output_node(x)]
print(f'Outputting {len(output_nodes)} nodes')

ops_writer = SwiftWriter()
for node in output_nodes:
    write_node(node, ops_writer)
ops_writer.output_to_file(ops_out_path)
