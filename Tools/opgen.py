import os
from typing import Dict, List, Optional, Tuple, Union
from pxr import Usd

class Node():
    def __init__(self, prim):
        self.name = str(prim.GetName())
        property_names = prim.GetPropertyNames()
        self.inputs = []
        self.outputs = []
        for pn in property_names:
            p = prim.GetAttribute(pn)
            if pn.startswith('inputs:'):
                self.inputs.append(NodeProperty(self, pn, p))
            if pn.startswith('outputs:'):
                self.outputs.append(NodeProperty(self, pn, p))

    def __str__(self):
        return f'{self.name} ({len(self.inputs)} inputs, {len(self.outputs)} outputs)'
    
class NodeProperty():
    def __init__(self, node: Node, property_name: str, p):
        self.property_name = property_name
        self.name = property_name.split(':')[-1]
        t = p.GetTypeName()
        self.type_name = t.type.typeName
        self.type_is_array = t.isArray
        self.default_value = p.Get() if p.HasValue() else None

    def __str__(self):
        return f'{self.name}: {self.type_name} = {self.default_value}'

def is_node(prim):
    path = str(prim.GetPath()).split('/')
    return len(path) == 2 and len(path[0]) == 0 and path[1].startswith('ND_')

manual_node_prefixes = [
    'ND_combine',
    'ND_convert_',
    'ND_constant_',
    'ND_swizzle_',
]

def should_output_node(node: Node):
    if node.name.startswith('ND_Internal'):
        print(f'Skipping {node.name} because it is internal')
        return False
    if len(node.outputs) != 1:
        print(f'Skipping {node.name} because it has {len(node.outputs)} outputs')
        return False
    for i in node.inputs:
        if i.type_is_array:
            print(f'Skipping {node.name} because it has an array input')
            return False
    if node.outputs[0].type_is_array:
        print(f'Skipping {node.name} because its output is an array')
        return False
    for prefix in manual_node_prefixes:
        if node.name.startswith(prefix):
            print(f'Skipping {node.name} because it is a manual node')
            return False
    return True

suffix_type_names: List[str] = [
    "_boolean",
    "_color3",
    "_color3B",
    "_color3FA",
    "_color3I",
    "_color4",
    "_color4B",
    "_color4FA",
    "_color4I",
    "_filename",
    "_float",
    "_floatB",
    "_floatI",
    "_half",
    "_half2",
    "_half2B",
    "_half2FA",
    "_half2I",
    "_half3",
    "_half3B",
    "_half3FA",
    "_half3I",
    "_half4",
    "_half4B",
    "_half4FA",
    "_half4I",
    "_halfB",
    "_halfI",
    "_integer",
    "_integer2",
    "_integer3",
    "_integer4",
    "_matrix22",
    "_matrix22FA",
    "_matrix33",
    "_matrix33FA",
    "_matrix44",
    "_matrix44FA",
    "_string",
    "_vector2",
    "_vector2B",
    "_vector2FA",
    "_vector2I",
    "_vector3",
    "_vector3B",
    "_vector3FA",
    "_vector3I",
    "_vector4",
    "_vector4B",
    "_vector4FA",
    "_vector4I",
]

def get_node_suffix_type_name(node: Node) -> Tuple[str, Optional[str]]:
    for suffix in suffix_type_names:
        if node.name.endswith(suffix):
            base_name = node.name[:-len(suffix)]
            return base_name, suffix
    return node.name, None

def usd_type_to_sgc_type(usd_type: str) -> str:
    if usd_type == 'bool':
        return 'Bool'
    if usd_type == 'float':
        return 'SGValue'
    if usd_type == 'GfMatrix2d':
        return 'SGValue'
    if usd_type == 'GfMatrix3d':
        return 'SGValue'
    if usd_type == 'GfMatrix4d':
        return 'SGValue'
    if usd_type == 'GfVec2f':
        return 'SGValue'
    if usd_type == 'GfVec2h':
        return 'SGValue'
    if usd_type == 'GfVec2i':
        return 'SGValue'
    if usd_type == 'GfVec3f':
        return 'SGValue'
    if usd_type == 'GfVec3h':
        return 'SGValue'
    if usd_type == 'GfVec3i':
        return 'SGValue'
    if usd_type == 'GfVec4f':
        return 'SGValue'
    if usd_type == 'GfVec4h':
        return 'SGValue'
    if usd_type == 'GfVec4i':
        return 'SGValue'
    if usd_type == 'int':
        return 'SGValue'
    if usd_type == 'pxr_half::half':
        return 'String'
    if usd_type == 'SdfAssetPath':
        return 'TextureResource'
    if usd_type == 'string':
        return 'String'
    if usd_type == 'TfToken':
        return 'String'
    print("Unknown USD type:", usd_type)
    return usd_type

class SwiftWriter():
    def __init__(self):
        self.lines = []
        self.current_line = ""
        self.write_header()

    def commit_current_line(self):
        if len(self.current_line) > 0:
            self.lines.append(self.current_line)
            self.current_line = ""

    def output_to_file(self, file_path: str):
        with open(file_path, 'w') as f:
            self.write_footer(f)
            for line in self.lines:
                f.write(line)
                f.write('\n')

    def write_header(self):
        self.write_line('// Autogenerated by opgen.py')
        self.write_line('import Foundation')
        self.write_line('')

    def write_footer(self, f):
        self.write_line('')

    def write_line(self, text: str):
        self.current_line += text
        self.commit_current_line()

    def write(self, text: str):
        self.current_line += text

class NodeOverloads():
    overloads: List[Tuple[Optional[str], Node]]
    is_src: bool
    def __init__(self, base_name: str, first_suffix_type_name: Optional[str], first_node: Node):
        self.base_name = base_name
        self.overloads = [(first_suffix_type_name, first_node)]
        self.is_src = len(first_node.inputs) == 0
    def add_overload(self, suffix_type_name: Optional[str], node: Node):
        self.overloads.append((suffix_type_name, node))

node_overloads: Dict[str, NodeOverloads] = {}

def add_node_to_overloads(node: Node):
    base_name, suffix_type_name = get_node_suffix_type_name(node)
    if base_name not in node_overloads:
        node_overloads[base_name] = NodeOverloads(base_name, suffix_type_name, node)
    else:
        node_overloads[base_name].add_overload(suffix_type_name, node)

def write_node_overloads(overloads: NodeOverloads, w: SwiftWriter):
    swift_name = overloads.base_name
    if swift_name.startswith('ND_realitykit_'):
        swift_name = swift_name[len('ND_realitykit_'):]
    elif swift_name.startswith('ND_'):
        swift_name = swift_name[len('ND_'):]
    first_node = overloads.overloads[0][1]
    w.write(f'public func {swift_name}(')
    for i, input in enumerate(first_node.inputs):
        w.write(f'{input.name}: {usd_type_to_sgc_type(input.type_name)}')
        if i < len(first_node.inputs) - 1:
            w.write(', ')
    output = first_node.outputs[0]
    w.write_line(f') -> {usd_type_to_sgc_type(output.type_name)} {{')
    w.write_line('}')

tools_path = os.path.dirname(os.path.abspath(__file__))
schemas_path = os.path.join(tools_path, 'schemas.usda')
src_path = os.path.abspath(os.path.join(tools_path, '..', 'Sources', 'ShaderGraphCoder'))

ops_out_path = os.path.join(src_path, 'Operations.g.swift')
srcs_out_path = os.path.join(src_path, 'Sources.g.swift')

stage = Usd.Stage.Open(schemas_path)
all_prims = [x for x in stage.Traverse()]  
nodes = [Node(x) for x in all_prims if is_node(x)]
print(f'Found {len(nodes)} nodes')
output_nodes = [x for x in nodes if should_output_node(x)]
print(f'Outputting {len(output_nodes)} nodes')
for node in output_nodes:
    add_node_to_overloads(node)
print(f'Outputting {len(node_overloads)} overloads')
src_nodes: List[NodeOverloads] = []
op_nodes: List[NodeOverloads] = []
for base_name, no in node_overloads.items():
    if no.is_src:
        src_nodes.append(no)
    else:
        op_nodes.append(no)
src_nodes = sorted(src_nodes, key=lambda x: x.base_name)
op_nodes = sorted(op_nodes, key=lambda x: x.base_name)
print(f'Outputting {len(op_nodes)} operations')
print(f'Outputting {len(src_nodes)} sources')

ops_writer = SwiftWriter()
for node in op_nodes:
    write_node_overloads(node, ops_writer)
ops_writer.output_to_file(ops_out_path)

srcs_writer = SwiftWriter()
for node in src_nodes:
    write_node_overloads(node, srcs_writer)
srcs_writer.output_to_file(srcs_out_path)
